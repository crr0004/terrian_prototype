!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AND_THEN	include/catch.hpp	9397;"	d
AND_WHEN	include/catch.hpp	9395;"	d
AssertionInfo	include/catch.hpp	/^        AssertionInfo(  std::string const& _macroName,$/;"	p	struct:Catch::AssertionInfo	access:public	signature:( std::string const& _macroName, SourceLineInfo const& _lineInfo, std::string const& _capturedExpression, ResultDisposition::Flags _resultDisposition )
AssertionInfo	include/catch.hpp	/^        AssertionInfo() {}$/;"	f	struct:Catch::AssertionInfo	access:public	signature:()
AssertionInfo	include/catch.hpp	/^    struct AssertionInfo$/;"	s	namespace:Catch
AssertionResult	include/catch.hpp	/^         AssertionResult( AssertionResult && )                  = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult && )
AssertionResult	include/catch.hpp	/^         AssertionResult( AssertionResult const& )              = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult const& )
AssertionResult	include/catch.hpp	/^        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionInfo const& info, AssertionResultData const& data )
AssertionResult	include/catch.hpp	/^        AssertionResult();$/;"	p	class:Catch::AssertionResult	access:public	signature:()
AssertionResult	include/catch.hpp	/^    class AssertionResult {$/;"	c	namespace:Catch
AssertionResultData	include/catch.hpp	/^        AssertionResultData() : resultType( ResultWas::Unknown ) {}$/;"	f	struct:Catch::AssertionResultData	access:public	signature:()
AssertionResultData	include/catch.hpp	/^    struct AssertionResultData$/;"	s	namespace:Catch
AutoReg	include/catch.hpp	/^    AutoReg(    TestFunction function,$/;"	p	struct:Catch::AutoReg	access:public	signature:( TestFunction function, SourceLineInfo const& lineInfo, NameAndDesc const& nameAndDesc )
AutoReg	include/catch.hpp	/^    AutoReg(    void (C::*method)(),$/;"	f	struct:Catch::AutoReg	access:public	signature:( void (C::*method)(), char const* className, NameAndDesc const& nameAndDesc, SourceLineInfo const& lineInfo )
AutoReg	include/catch.hpp	/^    AutoReg( AutoReg const& );$/;"	p	struct:Catch::AutoReg	access:private	signature:( AutoReg const& )
AutoReg	include/catch.hpp	/^struct AutoReg {$/;"	s	namespace:Catch
BorgType	include/catch.hpp	/^        template<typename T> BorgType( T const& );$/;"	p	struct:Catch::Detail::BorgType	access:public	signature:( T const& )
BorgType	include/catch.hpp	/^    struct BorgType {$/;"	s	namespace:Catch::Detail
CATCH_AND_THEN	include/catch.hpp	9328;"	d
CATCH_AND_WHEN	include/catch.hpp	9326;"	d
CATCH_ANON_TEST_CASE	include/catch.hpp	9309;"	d
CATCH_ARC_ENABLED	include/catch.hpp	1027;"	d
CATCH_ARC_STRONG	include/catch.hpp	1045;"	d
CATCH_ARC_STRONG	include/catch.hpp	1061;"	d
CATCH_BREAK_INTO_DEBUGGER	include/catch.hpp	1527;"	d
CATCH_BREAK_INTO_DEBUGGER	include/catch.hpp	1545;"	d
CATCH_CAPTURE	include/catch.hpp	9291;"	d
CATCH_CHECK	include/catch.hpp	9275;"	d
CATCH_CHECKED_ELSE	include/catch.hpp	9278;"	d
CATCH_CHECKED_IF	include/catch.hpp	9277;"	d
CATCH_CHECK_FALSE	include/catch.hpp	9276;"	d
CATCH_CHECK_NOFAIL	include/catch.hpp	9279;"	d
CATCH_CHECK_NOTHROW	include/catch.hpp	9283;"	d
CATCH_CHECK_THROWS	include/catch.hpp	9281;"	d
CATCH_CHECK_THROWS_AS	include/catch.hpp	9282;"	d
CATCH_CONFIG_COLOUR_WINDOWS	include/catch.hpp	6262;"	d
CATCH_CONFIG_CONSOLE_WIDTH	include/catch.hpp	3117;"	d
CATCH_CONFIG_CPP11_GENERATED_METHODS	include/catch.hpp	206;"	d
CATCH_CONFIG_CPP11_IS_ENUM	include/catch.hpp	209;"	d
CATCH_CONFIG_CPP11_NOEXCEPT	include/catch.hpp	203;"	d
CATCH_CONFIG_CPP11_NULLPTR	include/catch.hpp	200;"	d
CATCH_CONFIG_CPP11_TUPLE	include/catch.hpp	212;"	d
CATCH_CONFIG_MAIN	tests/main.cpp	1;"	d	file:
CATCH_CONFIG_VARIADIC_MACROS	include/catch.hpp	215;"	d
CATCH_CPP11_OR_GREATER	include/catch.hpp	170;"	d
CATCH_FAIL	include/catch.hpp	9299;"	d
CATCH_GENERATE	include/catch.hpp	9314;"	d
CATCH_GIVEN	include/catch.hpp	9324;"	d
CATCH_IMPL	include/catch.hpp	49;"	d
CATCH_INFO	include/catch.hpp	9288;"	d
CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	include/catch.hpp	149;"	d
CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	include/catch.hpp	181;"	d
CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM	include/catch.hpp	185;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	include/catch.hpp	106;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	include/catch.hpp	148;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	include/catch.hpp	177;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	include/catch.hpp	102;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	include/catch.hpp	134;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	include/catch.hpp	144;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	include/catch.hpp	173;"	d
CATCH_INTERNAL_CONFIG_CPP11_TUPLE	include/catch.hpp	189;"	d
CATCH_INTERNAL_CONFIG_VARIADIC_MACROS	include/catch.hpp	160;"	d
CATCH_INTERNAL_CONFIG_VARIADIC_MACROS	include/catch.hpp	193;"	d
CATCH_INTERNAL_ERROR	include/catch.hpp	331;"	d
CATCH_INTERNAL_LINEINFO	include/catch.hpp	330;"	d
CATCH_METHOD_AS_TEST_CASE	include/catch.hpp	9297;"	d
CATCH_NOEXCEPT	include/catch.hpp	/^        virtual const char* what() const CATCH_NOEXCEPT;$/;"	m	class:Catch::NotImplementedException	access:public
CATCH_NOEXCEPT	include/catch.hpp	220;"	d
CATCH_NOEXCEPT	include/catch.hpp	223;"	d
CATCH_NOEXCEPT_IS	include/catch.hpp	221;"	d
CATCH_NOEXCEPT_IS	include/catch.hpp	224;"	d
CATCH_NOT_IMPLEMENTED	include/catch.hpp	355;"	d
CATCH_PLATFORM_MAC	include/catch.hpp	1506;"	d
CATCH_REGISTER_LEGACY_REPORTER	include/catch.hpp	9312;"	d
CATCH_REGISTER_REPORTER	include/catch.hpp	9311;"	d
CATCH_REGISTER_TAG_ALIAS	include/catch.hpp	2433;"	d
CATCH_REQUIRE	include/catch.hpp	9268;"	d
CATCH_REQUIRE_FALSE	include/catch.hpp	9269;"	d
CATCH_REQUIRE_NOTHROW	include/catch.hpp	9273;"	d
CATCH_REQUIRE_THAT	include/catch.hpp	9286;"	d
CATCH_REQUIRE_THROWS	include/catch.hpp	9271;"	d
CATCH_REQUIRE_THROWS_AS	include/catch.hpp	9272;"	d
CATCH_SCENARIO	include/catch.hpp	9318;"	d
CATCH_SCENARIO_METHOD	include/catch.hpp	9319;"	d
CATCH_SCOPED_CAPTURE	include/catch.hpp	9292;"	d
CATCH_SCOPED_INFO	include/catch.hpp	9290;"	d
CATCH_SECTION	include/catch.hpp	9298;"	d
CATCH_SUCCEED	include/catch.hpp	9300;"	d
CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH	include/catch.hpp	3262;"	d
CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH	include/catch.hpp	4122;"	d
CATCH_TEST_CASE	include/catch.hpp	9295;"	d
CATCH_TEST_CASE_METHOD	include/catch.hpp	9296;"	d
CATCH_THEN	include/catch.hpp	9327;"	d
CATCH_TRANSLATE_EXCEPTION	include/catch.hpp	9383;"	d
CATCH_UNSAFE_UNRETAINED	include/catch.hpp	1044;"	d
CATCH_UNSAFE_UNRETAINED	include/catch.hpp	1060;"	d
CATCH_WARN	include/catch.hpp	9289;"	d
CATCH_WHEN	include/catch.hpp	9325;"	d
CHECK_THAT	include/catch.hpp	9285;"	d
CLARA_CONFIG_CONSOLE_WIDTH	include/catch.hpp	3263;"	d
CLARA_CONFIG_CONSOLE_WIDTH	include/catch.hpp	3265;"	d
CLARA_CONFIG_CONSOLE_WIDTH	include/catch.hpp	4121;"	d
CLARA_CONFIG_MAIN	include/catch.hpp	55;"	d
CLARA_CONFIG_MAIN	include/catch.hpp	9260;"	d
CLARA_CONFIG_MAIN_NOT_DEFINED	include/catch.hpp	54;"	d
CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE	include/catch.hpp	4300;"	d
CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE	include/catch.hpp	4448;"	d
Catch	include/catch.hpp	/^namespace Catch {$/;"	n
Catch::AssertionInfo	include/catch.hpp	/^    struct AssertionInfo$/;"	s	namespace:Catch
Catch::AssertionInfo::AssertionInfo	include/catch.hpp	/^        AssertionInfo(  std::string const& _macroName,$/;"	p	struct:Catch::AssertionInfo	access:public	signature:( std::string const& _macroName, SourceLineInfo const& _lineInfo, std::string const& _capturedExpression, ResultDisposition::Flags _resultDisposition )
Catch::AssertionInfo::AssertionInfo	include/catch.hpp	/^        AssertionInfo() {}$/;"	f	struct:Catch::AssertionInfo	access:public	signature:()
Catch::AssertionInfo::capturedExpression	include/catch.hpp	/^        std::string capturedExpression;$/;"	m	struct:Catch::AssertionInfo	access:public
Catch::AssertionInfo::lineInfo	include/catch.hpp	/^        SourceLineInfo lineInfo;$/;"	m	struct:Catch::AssertionInfo	access:public
Catch::AssertionInfo::macroName	include/catch.hpp	/^        std::string macroName;$/;"	m	struct:Catch::AssertionInfo	access:public
Catch::AssertionInfo::resultDisposition	include/catch.hpp	/^        ResultDisposition::Flags resultDisposition;$/;"	m	struct:Catch::AssertionInfo	access:public
Catch::AssertionResult	include/catch.hpp	/^    class AssertionResult {$/;"	c	namespace:Catch
Catch::AssertionResult::AssertionResult	include/catch.hpp	/^         AssertionResult( AssertionResult && )                  = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult && )
Catch::AssertionResult::AssertionResult	include/catch.hpp	/^         AssertionResult( AssertionResult const& )              = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult const& )
Catch::AssertionResult::AssertionResult	include/catch.hpp	/^        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionInfo const& info, AssertionResultData const& data )
Catch::AssertionResult::AssertionResult	include/catch.hpp	/^        AssertionResult();$/;"	p	class:Catch::AssertionResult	access:public	signature:()
Catch::AssertionResult::getExpandedExpression	include/catch.hpp	/^        std::string getExpandedExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::getExpression	include/catch.hpp	/^        std::string getExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::getExpressionInMacro	include/catch.hpp	/^        std::string getExpressionInMacro() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::getMessage	include/catch.hpp	/^        std::string getMessage() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::getResultType	include/catch.hpp	/^        ResultWas::OfType getResultType() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::getSourceInfo	include/catch.hpp	/^        SourceLineInfo getSourceInfo() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::getTestMacroName	include/catch.hpp	/^        std::string getTestMacroName() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::hasExpandedExpression	include/catch.hpp	/^        bool hasExpandedExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::hasExpression	include/catch.hpp	/^        bool hasExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::hasMessage	include/catch.hpp	/^        bool hasMessage() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::isOk	include/catch.hpp	/^        bool isOk() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::m_info	include/catch.hpp	/^        AssertionInfo m_info;$/;"	m	class:Catch::AssertionResult	access:protected
Catch::AssertionResult::m_resultData	include/catch.hpp	/^        AssertionResultData m_resultData;$/;"	m	class:Catch::AssertionResult	access:protected
Catch::AssertionResult::operator =	include/catch.hpp	/^         AssertionResult& operator = ( AssertionResult && )     = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult && )
Catch::AssertionResult::operator =	include/catch.hpp	/^         AssertionResult& operator = ( AssertionResult const& ) = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult const& )
Catch::AssertionResult::succeeded	include/catch.hpp	/^        bool succeeded() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
Catch::AssertionResult::~AssertionResult	include/catch.hpp	/^        ~AssertionResult();$/;"	p	class:Catch::AssertionResult	access:public	signature:()
Catch::AssertionResultData	include/catch.hpp	/^    struct AssertionResultData$/;"	s	namespace:Catch
Catch::AssertionResultData::AssertionResultData	include/catch.hpp	/^        AssertionResultData() : resultType( ResultWas::Unknown ) {}$/;"	f	struct:Catch::AssertionResultData	access:public	signature:()
Catch::AssertionResultData::message	include/catch.hpp	/^        std::string message;$/;"	m	struct:Catch::AssertionResultData	access:public
Catch::AssertionResultData::reconstructedExpression	include/catch.hpp	/^        std::string reconstructedExpression;$/;"	m	struct:Catch::AssertionResultData	access:public
Catch::AssertionResultData::resultType	include/catch.hpp	/^        ResultWas::OfType resultType;$/;"	m	struct:Catch::AssertionResultData	access:public
Catch::AutoReg	include/catch.hpp	/^struct AutoReg {$/;"	s	namespace:Catch
Catch::AutoReg::AutoReg	include/catch.hpp	/^    AutoReg(    TestFunction function,$/;"	p	struct:Catch::AutoReg	access:public	signature:( TestFunction function, SourceLineInfo const& lineInfo, NameAndDesc const& nameAndDesc )
Catch::AutoReg::AutoReg	include/catch.hpp	/^    AutoReg(    void (C::*method)(),$/;"	f	struct:Catch::AutoReg	access:public	signature:( void (C::*method)(), char const* className, NameAndDesc const& nameAndDesc, SourceLineInfo const& lineInfo )
Catch::AutoReg::AutoReg	include/catch.hpp	/^    AutoReg( AutoReg const& );$/;"	p	struct:Catch::AutoReg	access:private	signature:( AutoReg const& )
Catch::AutoReg::operator =	include/catch.hpp	/^    void operator= ( AutoReg const& );$/;"	p	struct:Catch::AutoReg	access:private	signature:( AutoReg const& )
Catch::AutoReg::registerTestCase	include/catch.hpp	/^    void registerTestCase(  ITestCase* testCase,$/;"	p	struct:Catch::AutoReg	access:public	signature:( ITestCase* testCase, char const* className, NameAndDesc const& nameAndDesc, SourceLineInfo const& lineInfo )
Catch::AutoReg::~AutoReg	include/catch.hpp	/^    ~AutoReg();$/;"	p	struct:Catch::AutoReg	access:public	signature:()
Catch::CopyableStream	include/catch.hpp	/^    struct CopyableStream {$/;"	s	namespace:Catch
Catch::CopyableStream::CopyableStream	include/catch.hpp	/^        CopyableStream( CopyableStream const& other ) {$/;"	f	struct:Catch::CopyableStream	access:public	signature:( CopyableStream const& other )
Catch::CopyableStream::CopyableStream	include/catch.hpp	/^        CopyableStream() {}$/;"	f	struct:Catch::CopyableStream	access:public	signature:()
Catch::CopyableStream::operator =	include/catch.hpp	/^        CopyableStream& operator=( CopyableStream const& other ) {$/;"	f	struct:Catch::CopyableStream	access:public	signature:( CopyableStream const& other )
Catch::CopyableStream::oss	include/catch.hpp	/^        std::ostringstream oss;$/;"	m	struct:Catch::CopyableStream	access:public
Catch::Detail	include/catch.hpp	/^namespace Detail {$/;"	n	namespace:Catch
Catch::Detail::BorgType	include/catch.hpp	/^    struct BorgType {$/;"	s	namespace:Catch::Detail
Catch::Detail::BorgType::BorgType	include/catch.hpp	/^        template<typename T> BorgType( T const& );$/;"	p	struct:Catch::Detail::BorgType	access:public	signature:( T const& )
Catch::Detail::EnumStringMaker	include/catch.hpp	/^    struct EnumStringMaker$/;"	s	namespace:Catch::Detail
Catch::Detail::EnumStringMaker	include/catch.hpp	/^    struct EnumStringMaker<T,true>$/;"	s	namespace:Catch::Detail
Catch::Detail::EnumStringMaker::convert	include/catch.hpp	/^        static std::string convert( T const& ) { return unprintableString; }$/;"	f	struct:Catch::Detail::EnumStringMaker	access:public	signature:( T const& )
Catch::Detail::EnumStringMaker::convert	include/catch.hpp	/^        static std::string convert( T const& v )$/;"	f	struct:Catch::Detail::EnumStringMaker	access:public	signature:( T const& v )
Catch::Detail::FalseType	include/catch.hpp	/^    struct FalseType { char sizer[2]; };$/;"	s	namespace:Catch::Detail
Catch::Detail::FalseType::sizer	include/catch.hpp	/^    struct FalseType { char sizer[2]; };$/;"	m	struct:Catch::Detail::FalseType	access:public
Catch::Detail::IsStreamInsertable	include/catch.hpp	/^    struct IsStreamInsertable {$/;"	s	namespace:Catch::Detail
Catch::Detail::IsStreamInsertable::s	include/catch.hpp	/^        static std::ostream &s;$/;"	m	struct:Catch::Detail::IsStreamInsertable	access:public
Catch::Detail::IsStreamInsertable::t	include/catch.hpp	/^        static T  const&t;$/;"	m	struct:Catch::Detail::IsStreamInsertable	access:public
Catch::Detail::IsStreamInsertable::value	include/catch.hpp	/^        enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };$/;"	e	enum:Catch::Detail::IsStreamInsertable::__anon1
Catch::Detail::StringMakerBase	include/catch.hpp	/^    struct StringMakerBase {$/;"	s	namespace:Catch::Detail
Catch::Detail::StringMakerBase	include/catch.hpp	/^    struct StringMakerBase<true> {$/;"	s	namespace:Catch::Detail
Catch::Detail::StringMakerBase::convert	include/catch.hpp	/^        static std::string convert( T const& _value ) {$/;"	f	struct:Catch::Detail::StringMakerBase	access:public	signature:( T const& _value )
Catch::Detail::StringMakerBase::convert	include/catch.hpp	/^        static std::string convert( T const& v )$/;"	f	struct:Catch::Detail::StringMakerBase	access:public	signature:( T const& v )
Catch::Detail::TrueType	include/catch.hpp	/^    struct TrueType { char sizer[1]; };$/;"	s	namespace:Catch::Detail
Catch::Detail::TrueType::sizer	include/catch.hpp	/^    struct TrueType { char sizer[1]; };$/;"	m	struct:Catch::Detail::TrueType	access:public
Catch::Detail::operator <<	include/catch.hpp	/^    FalseType operator<<( std::ostream const&, BorgType const& );$/;"	p	namespace:Catch::Detail	signature:( std::ostream const&, BorgType const& )
Catch::Detail::rangeToString	include/catch.hpp	/^    std::string rangeToString( InputIterator first, InputIterator last );$/;"	p	namespace:Catch::Detail	signature:( InputIterator first, InputIterator last )
Catch::Detail::rawMemoryToString	include/catch.hpp	/^    inline std::string rawMemoryToString( const T& object ) {$/;"	f	namespace:Catch::Detail	signature:( const T& object )
Catch::Detail::rawMemoryToString	include/catch.hpp	/^    std::string rawMemoryToString( const void *object, std::size_t size );$/;"	p	namespace:Catch::Detail	signature:( const void *object, std::size_t size )
Catch::Detail::testStreamable	include/catch.hpp	/^    FalseType testStreamable( FalseType );$/;"	p	namespace:Catch::Detail	signature:( FalseType )
Catch::Detail::testStreamable	include/catch.hpp	/^    TrueType& testStreamable( std::ostream& );$/;"	p	namespace:Catch::Detail	signature:( std::ostream& )
Catch::IContext	include/catch.hpp	/^    struct IContext$/;"	s	namespace:Catch
Catch::IContext::advanceGeneratorsForCurrentTest	include/catch.hpp	/^        virtual bool advanceGeneratorsForCurrentTest() = 0;$/;"	p	struct:Catch::IContext	access:public	signature:()
Catch::IContext::getConfig	include/catch.hpp	/^        virtual Ptr<IConfig const> getConfig() const = 0;$/;"	p	struct:Catch::IContext	access:public	signature:() const
Catch::IContext::getGeneratorIndex	include/catch.hpp	/^        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) = 0;$/;"	p	struct:Catch::IContext	access:public	signature:( std::string const& fileInfo, size_t totalSize )
Catch::IContext::getResultCapture	include/catch.hpp	/^        virtual IResultCapture* getResultCapture() = 0;$/;"	p	struct:Catch::IContext	access:public	signature:()
Catch::IContext::getRunner	include/catch.hpp	/^        virtual IRunner* getRunner() = 0;$/;"	p	struct:Catch::IContext	access:public	signature:()
Catch::IContext::~IContext	include/catch.hpp	/^        virtual ~IContext();$/;"	p	struct:Catch::IContext	access:public	signature:()
Catch::IGeneratorInfo	include/catch.hpp	/^    struct IGeneratorInfo {$/;"	s	namespace:Catch
Catch::IGeneratorInfo::getCurrentIndex	include/catch.hpp	/^        virtual std::size_t getCurrentIndex() const = 0;$/;"	p	struct:Catch::IGeneratorInfo	access:public	signature:() const
Catch::IGeneratorInfo::moveNext	include/catch.hpp	/^        virtual bool moveNext() = 0;$/;"	p	struct:Catch::IGeneratorInfo	access:public	signature:()
Catch::IGeneratorInfo::~IGeneratorInfo	include/catch.hpp	/^        virtual ~IGeneratorInfo();$/;"	p	struct:Catch::IGeneratorInfo	access:public	signature:()
Catch::IGeneratorsForTest	include/catch.hpp	/^    struct IGeneratorsForTest {$/;"	s	namespace:Catch
Catch::IGeneratorsForTest::getGeneratorInfo	include/catch.hpp	/^        virtual IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) = 0;$/;"	p	struct:Catch::IGeneratorsForTest	access:public	signature:( std::string const& fileInfo, std::size_t size )
Catch::IGeneratorsForTest::moveNext	include/catch.hpp	/^        virtual bool moveNext() = 0;$/;"	p	struct:Catch::IGeneratorsForTest	access:public	signature:()
Catch::IGeneratorsForTest::~IGeneratorsForTest	include/catch.hpp	/^        virtual ~IGeneratorsForTest();$/;"	p	struct:Catch::IGeneratorsForTest	access:public	signature:()
Catch::IMutableContext	include/catch.hpp	/^    struct IMutableContext : IContext$/;"	s	namespace:Catch	inherits:IContext
Catch::IMutableContext::setConfig	include/catch.hpp	/^        virtual void setConfig( Ptr<IConfig const> const& config ) = 0;$/;"	p	struct:Catch::IMutableContext	access:public	signature:( Ptr<IConfig const> const& config )
Catch::IMutableContext::setResultCapture	include/catch.hpp	/^        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;$/;"	p	struct:Catch::IMutableContext	access:public	signature:( IResultCapture* resultCapture )
Catch::IMutableContext::setRunner	include/catch.hpp	/^        virtual void setRunner( IRunner* runner ) = 0;$/;"	p	struct:Catch::IMutableContext	access:public	signature:( IRunner* runner )
Catch::IMutableContext::~IMutableContext	include/catch.hpp	/^        virtual ~IMutableContext();$/;"	p	struct:Catch::IMutableContext	access:public	signature:()
Catch::IShared	include/catch.hpp	/^    struct IShared : NonCopyable {$/;"	s	namespace:Catch	inherits:NonCopyable
Catch::IShared::addRef	include/catch.hpp	/^        virtual void addRef() const = 0;$/;"	p	struct:Catch::IShared	access:public	signature:() const
Catch::IShared::release	include/catch.hpp	/^        virtual void release() const = 0;$/;"	p	struct:Catch::IShared	access:public	signature:() const
Catch::IShared::~IShared	include/catch.hpp	/^        virtual ~IShared();$/;"	p	struct:Catch::IShared	access:public	signature:()
Catch::ITestCase	include/catch.hpp	/^    struct ITestCase : IShared {$/;"	s	namespace:Catch	inherits:IShared
Catch::ITestCase::invoke	include/catch.hpp	/^        virtual void invoke () const = 0;$/;"	p	struct:Catch::ITestCase	access:public	signature:() const
Catch::ITestCase::~ITestCase	include/catch.hpp	/^        virtual ~ITestCase();$/;"	p	struct:Catch::ITestCase	access:protected	signature:()
Catch::ITestCaseRegistry	include/catch.hpp	/^    struct ITestCaseRegistry {$/;"	s	namespace:Catch
Catch::ITestCaseRegistry::getFilteredTests	include/catch.hpp	/^        virtual void getFilteredTests( TestSpec const& testSpec, IConfig const& config, std::vector<TestCase>& matchingTestCases, bool negated = false ) const = 0;$/;"	p	struct:Catch::ITestCaseRegistry	access:public	signature:( TestSpec const& testSpec, IConfig const& config, std::vector<TestCase>& matchingTestCases, bool negated = false ) const
Catch::ITestCaseRegistry::std::getAllTests	include/catch.hpp	/^        virtual std::vector<TestCase> const& getAllTests() const = 0;$/;"	p	class:Catch::ITestCaseRegistry::std	access:public	signature:() const
Catch::ITestCaseRegistry::~ITestCaseRegistry	include/catch.hpp	/^        virtual ~ITestCaseRegistry();$/;"	p	struct:Catch::ITestCaseRegistry	access:public	signature:()
Catch::Internal	include/catch.hpp	/^namespace Internal {$/;"	n	namespace:Catch
Catch::Internal::Evaluator	include/catch.hpp	/^    class Evaluator{};$/;"	c	namespace:Catch::Internal
Catch::Internal::Evaluator	include/catch.hpp	/^    struct Evaluator<T1, T2, IsEqualTo> {$/;"	s	namespace:Catch::Internal
Catch::Internal::Evaluator	include/catch.hpp	/^    struct Evaluator<T1, T2, IsGreaterThan> {$/;"	s	namespace:Catch::Internal
Catch::Internal::Evaluator	include/catch.hpp	/^    struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Catch::Internal::Evaluator	include/catch.hpp	/^    struct Evaluator<T1, T2, IsLessThan> {$/;"	s	namespace:Catch::Internal
Catch::Internal::Evaluator	include/catch.hpp	/^    struct Evaluator<T1, T2, IsLessThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Catch::Internal::Evaluator	include/catch.hpp	/^    struct Evaluator<T1, T2, IsNotEqualTo> {$/;"	s	namespace:Catch::Internal
Catch::Internal::Evaluator::evaluate	include/catch.hpp	/^        static bool evaluate( T1 const& lhs, T2 const& rhs ) {$/;"	f	struct:Catch::Internal::Evaluator	access:public	signature:( T1 const& lhs, T2 const& rhs )
Catch::Internal::Evaluator::evaluate	include/catch.hpp	/^        static bool evaluate( T1 const& lhs, T2 const& rhs) {$/;"	f	struct:Catch::Internal::Evaluator	access:public	signature:( T1 const& lhs, T2 const& rhs)
Catch::Internal::IsEqualTo	include/catch.hpp	/^        IsEqualTo,$/;"	e	enum:Catch::Internal::Operator
Catch::Internal::IsGreaterThan	include/catch.hpp	/^        IsGreaterThan,$/;"	e	enum:Catch::Internal::Operator
Catch::Internal::IsGreaterThanOrEqualTo	include/catch.hpp	/^        IsGreaterThanOrEqualTo$/;"	e	enum:Catch::Internal::Operator
Catch::Internal::IsLessThan	include/catch.hpp	/^        IsLessThan,$/;"	e	enum:Catch::Internal::Operator
Catch::Internal::IsLessThanOrEqualTo	include/catch.hpp	/^        IsLessThanOrEqualTo,$/;"	e	enum:Catch::Internal::Operator
Catch::Internal::IsNotEqualTo	include/catch.hpp	/^        IsNotEqualTo,$/;"	e	enum:Catch::Internal::Operator
Catch::Internal::Operator	include/catch.hpp	/^    enum Operator {$/;"	g	namespace:Catch::Internal
Catch::Internal::OperatorTraits	include/catch.hpp	/^    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits	include/catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits	include/catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits	include/catch.hpp	/^    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits	include/catch.hpp	/^    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits	include/catch.hpp	/^    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits	include/catch.hpp	/^    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };$/;"	s	namespace:Catch::Internal
Catch::Internal::OperatorTraits::getName	include/catch.hpp	/^    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::OperatorTraits::getName	include/catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::OperatorTraits::getName	include/catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::OperatorTraits::getName	include/catch.hpp	/^    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::OperatorTraits::getName	include/catch.hpp	/^    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::OperatorTraits::getName	include/catch.hpp	/^    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::OperatorTraits::getName	include/catch.hpp	/^    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
Catch::Internal::applyEvaluator	include/catch.hpp	/^    bool applyEvaluator( T1 const& lhs, T2 const& rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T1 const& lhs, T2 const& rhs )
Catch::Internal::compare	include/catch.hpp	/^    bool compare( T1 const& lhs, T2 const& rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T1 const& lhs, T2 const& rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, int rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, long rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, std::nullptr_t ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, std::nullptr_t )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op, typename T> bool compare( int lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, T* rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op, typename T> bool compare( long lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, T* rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op, typename T> bool compare( std::nullptr_t, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( std::nullptr_t, T* rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, unsigned char rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, unsigned int rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, unsigned long rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, unsigned char rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, unsigned int rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, unsigned long rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op> bool compare( unsigned char lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned char lhs, int rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op> bool compare( unsigned char lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned char lhs, long rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op> bool compare( unsigned int lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned int lhs, int rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op> bool compare( unsigned int lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned int lhs, long rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op> bool compare( unsigned long lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long lhs, int rhs )
Catch::Internal::compare	include/catch.hpp	/^    template<Operator Op> bool compare( unsigned long lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long lhs, long rhs )
Catch::Internal::opCast	include/catch.hpp	/^    inline T& opCast(T const& t) { return const_cast<T&>(t); }$/;"	f	namespace:Catch::Internal	signature:(T const& t)
Catch::Internal::opCast	include/catch.hpp	/^    inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }$/;"	f	namespace:Catch::Internal	signature:(std::nullptr_t)
Catch::MethodTestCase	include/catch.hpp	/^class MethodTestCase : public SharedImpl<ITestCase> {$/;"	c	namespace:Catch	inherits:SharedImpl
Catch::MethodTestCase::MethodTestCase	include/catch.hpp	/^    MethodTestCase( void (C::*method)() ) : m_method( method ) {}$/;"	f	class:Catch::MethodTestCase	access:public	signature:( void (C::*method)() )
Catch::MethodTestCase::invoke	include/catch.hpp	/^    virtual void invoke() const {$/;"	f	class:Catch::MethodTestCase	access:public	signature:() const
Catch::MethodTestCase::m_method	include/catch.hpp	/^    void (C::*m_method)();$/;"	m	class:Catch::MethodTestCase	access:private
Catch::MethodTestCase::~MethodTestCase	include/catch.hpp	/^    virtual ~MethodTestCase() {}$/;"	f	class:Catch::MethodTestCase	access:private	signature:()
Catch::NameAndDesc	include/catch.hpp	/^struct NameAndDesc {$/;"	s	namespace:Catch
Catch::NameAndDesc::NameAndDesc	include/catch.hpp	/^    NameAndDesc( const char* _name = "", const char* _description= "" )$/;"	f	struct:Catch::NameAndDesc	access:public	signature:( const char* _name = Ó, const char* _description= Ó )
Catch::NameAndDesc::description	include/catch.hpp	/^    const char* description;$/;"	m	struct:Catch::NameAndDesc	access:public
Catch::NameAndDesc::name	include/catch.hpp	/^    const char* name;$/;"	m	struct:Catch::NameAndDesc	access:public
Catch::NonCopyable	include/catch.hpp	/^    class NonCopyable {$/;"	c	namespace:Catch
Catch::NonCopyable::NonCopyable	include/catch.hpp	/^        NonCopyable( NonCopyable && )                  = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable && )
Catch::NonCopyable::NonCopyable	include/catch.hpp	/^        NonCopyable( NonCopyable const& )              = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable const& )
Catch::NonCopyable::NonCopyable	include/catch.hpp	/^        NonCopyable() {}$/;"	f	class:Catch::NonCopyable	access:protected	signature:()
Catch::NonCopyable::operator =	include/catch.hpp	/^        NonCopyable& operator = ( NonCopyable && )     = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable && )
Catch::NonCopyable::operator =	include/catch.hpp	/^        NonCopyable& operator = ( NonCopyable const& ) = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable const& )
Catch::NonCopyable::~NonCopyable	include/catch.hpp	/^        virtual ~NonCopyable();$/;"	p	class:Catch::NonCopyable	access:protected	signature:()
Catch::NotImplementedException	include/catch.hpp	/^    class NotImplementedException : public std::exception$/;"	c	namespace:Catch	inherits:std::exception
Catch::NotImplementedException::CATCH_NOEXCEPT	include/catch.hpp	/^        virtual const char* what() const CATCH_NOEXCEPT;$/;"	m	class:Catch::NotImplementedException	access:public
Catch::NotImplementedException::NotImplementedException	include/catch.hpp	/^        NotImplementedException( NotImplementedException const& ) {}$/;"	f	class:Catch::NotImplementedException	access:public	signature:( NotImplementedException const& )
Catch::NotImplementedException::NotImplementedException	include/catch.hpp	/^        NotImplementedException( SourceLineInfo const& lineInfo );$/;"	p	class:Catch::NotImplementedException	access:public	signature:( SourceLineInfo const& lineInfo )
Catch::NotImplementedException::m_lineInfo	include/catch.hpp	/^        SourceLineInfo m_lineInfo;$/;"	m	class:Catch::NotImplementedException	access:private
Catch::NotImplementedException::m_what	include/catch.hpp	/^        std::string m_what;$/;"	m	class:Catch::NotImplementedException	access:private
Catch::Ptr	include/catch.hpp	/^    class Ptr {$/;"	c	namespace:Catch
Catch::Ptr::Ptr	include/catch.hpp	/^        Ptr( Ptr const& other ) : m_p( other.m_p ){$/;"	f	class:Catch::Ptr	access:public	signature:( Ptr const& other )
Catch::Ptr::Ptr	include/catch.hpp	/^        Ptr( T* p ) : m_p( p ){$/;"	f	class:Catch::Ptr	access:public	signature:( T* p )
Catch::Ptr::Ptr	include/catch.hpp	/^        Ptr() : m_p( NULL ){}$/;"	f	class:Catch::Ptr	access:public	signature:()
Catch::Ptr::get	include/catch.hpp	/^        T* get() { return m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:()
Catch::Ptr::get	include/catch.hpp	/^        const T* get() const{ return m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
Catch::Ptr::m_p	include/catch.hpp	/^        T* m_p;$/;"	m	class:Catch::Ptr	access:private
Catch::Ptr::operator !	include/catch.hpp	/^        bool operator !() const { return m_p == NULL; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
Catch::Ptr::operator *	include/catch.hpp	/^        T& operator*() const { return *m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
Catch::Ptr::operator ->	include/catch.hpp	/^        T* operator->() const { return m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
Catch::Ptr::operator =	include/catch.hpp	/^        Ptr& operator = ( Ptr const& other ){$/;"	f	class:Catch::Ptr	access:public	signature:( Ptr const& other )
Catch::Ptr::operator =	include/catch.hpp	/^        Ptr& operator = ( T* p ){$/;"	f	class:Catch::Ptr	access:public	signature:( T* p )
Catch::Ptr::operator SafeBool::type	include/catch.hpp	/^        operator SafeBool::type() const { return SafeBool::makeSafe( m_p != NULL ); }$/;"	f	class:Catch::Ptr	access:public	signature:() const
Catch::Ptr::reset	include/catch.hpp	/^        void reset() {$/;"	f	class:Catch::Ptr	access:public	signature:()
Catch::Ptr::swap	include/catch.hpp	/^        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }$/;"	f	class:Catch::Ptr	access:public	signature:( Ptr& other )
Catch::Ptr::~Ptr	include/catch.hpp	/^        ~Ptr(){$/;"	f	class:Catch::Ptr	access:public	signature:()
Catch::ResultBuilder	include/catch.hpp	/^    class ResultBuilder {$/;"	c	namespace:Catch
Catch::ResultBuilder::ExprComponents	include/catch.hpp	/^        struct ExprComponents {$/;"	s	class:Catch::ResultBuilder	access:private
Catch::ResultBuilder::ExprComponents::ExprComponents	include/catch.hpp	/^            ExprComponents() : testFalse( false ) {}$/;"	f	struct:Catch::ResultBuilder::ExprComponents	access:public	signature:()
Catch::ResultBuilder::ExprComponents::lhs	include/catch.hpp	/^            std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
Catch::ResultBuilder::ExprComponents::op	include/catch.hpp	/^            std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
Catch::ResultBuilder::ExprComponents::rhs	include/catch.hpp	/^            std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
Catch::ResultBuilder::ExprComponents::testFalse	include/catch.hpp	/^            bool testFalse;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
Catch::ResultBuilder::ResultBuilder	include/catch.hpp	/^        ResultBuilder(  char const* macroName,$/;"	p	class:Catch::ResultBuilder	access:public	signature:( char const* macroName, SourceLineInfo const& lineInfo, char const* capturedExpression, ResultDisposition::Flags resultDisposition )
Catch::ResultBuilder::allowThrows	include/catch.hpp	/^        bool allowThrows() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
Catch::ResultBuilder::build	include/catch.hpp	/^        AssertionResult build() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
Catch::ResultBuilder::captureExpression	include/catch.hpp	/^        void captureExpression();$/;"	p	class:Catch::ResultBuilder	access:public	signature:()
Catch::ResultBuilder::captureResult	include/catch.hpp	/^        void captureResult( ResultWas::OfType resultType );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( ResultWas::OfType resultType )
Catch::ResultBuilder::endExpression	include/catch.hpp	/^        void endExpression();$/;"	p	class:Catch::ResultBuilder	access:public	signature:()
Catch::ResultBuilder::m_assertionInfo	include/catch.hpp	/^        AssertionInfo m_assertionInfo;$/;"	m	class:Catch::ResultBuilder	access:private
Catch::ResultBuilder::m_data	include/catch.hpp	/^        AssertionResultData m_data;$/;"	m	class:Catch::ResultBuilder	access:private
Catch::ResultBuilder::m_exprComponents	include/catch.hpp	/^        } m_exprComponents;$/;"	m	class:Catch::ResultBuilder	typeref:struct:Catch::ResultBuilder::ExprComponents	access:private
Catch::ResultBuilder::m_shouldDebugBreak	include/catch.hpp	/^        bool m_shouldDebugBreak;$/;"	m	class:Catch::ResultBuilder	access:private
Catch::ResultBuilder::m_shouldThrow	include/catch.hpp	/^        bool m_shouldThrow;$/;"	m	class:Catch::ResultBuilder	access:private
Catch::ResultBuilder::m_stream	include/catch.hpp	/^        CopyableStream m_stream;$/;"	m	class:Catch::ResultBuilder	access:private
Catch::ResultBuilder::operator &&	include/catch.hpp	/^        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && ( RhsT const& );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( RhsT const& )
Catch::ResultBuilder::operator <<	include/catch.hpp	/^        ResultBuilder& operator << ( T const& value ) {$/;"	f	class:Catch::ResultBuilder	access:public	signature:( T const& value )
Catch::ResultBuilder::operator <=	include/catch.hpp	/^        ExpressionLhs<T const&> operator <= ( T const& operand );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( T const& operand )
Catch::ResultBuilder::operator <=	include/catch.hpp	/^        ExpressionLhs<bool> operator <= ( bool value );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( bool value )
Catch::ResultBuilder::operator ||	include/catch.hpp	/^        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || ( RhsT const& );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( RhsT const& )
Catch::ResultBuilder::react	include/catch.hpp	/^        void react();$/;"	p	class:Catch::ResultBuilder	access:public	signature:()
Catch::ResultBuilder::reconstructExpression	include/catch.hpp	/^        std::string reconstructExpression() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
Catch::ResultBuilder::setLhs	include/catch.hpp	/^        ResultBuilder& setLhs( std::string const& lhs );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& lhs )
Catch::ResultBuilder::setOp	include/catch.hpp	/^        ResultBuilder& setOp( std::string const& op );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& op )
Catch::ResultBuilder::setResultType	include/catch.hpp	/^        ResultBuilder& setResultType( ResultWas::OfType result );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( ResultWas::OfType result )
Catch::ResultBuilder::setResultType	include/catch.hpp	/^        ResultBuilder& setResultType( bool result );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( bool result )
Catch::ResultBuilder::setRhs	include/catch.hpp	/^        ResultBuilder& setRhs( std::string const& rhs );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& rhs )
Catch::ResultBuilder::shouldDebugBreak	include/catch.hpp	/^        bool shouldDebugBreak() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
Catch::ResultBuilder::useActiveException	include/catch.hpp	/^        void useActiveException( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal )
Catch::ResultDisposition	include/catch.hpp	/^    struct ResultDisposition { enum Flags {$/;"	s	namespace:Catch
Catch::ResultDisposition::ContinueOnFailure	include/catch.hpp	/^        ContinueOnFailure = 0x02,   \/\/ Failures fail test, but execution continues$/;"	e	enum:Catch::ResultDisposition::Flags
Catch::ResultDisposition::FalseTest	include/catch.hpp	/^        FalseTest = 0x04,           \/\/ Prefix expression with !$/;"	e	enum:Catch::ResultDisposition::Flags
Catch::ResultDisposition::Flags	include/catch.hpp	/^    struct ResultDisposition { enum Flags {$/;"	g	struct:Catch::ResultDisposition	access:public
Catch::ResultDisposition::Normal	include/catch.hpp	/^        Normal = 0x01,$/;"	e	enum:Catch::ResultDisposition::Flags
Catch::ResultDisposition::SuppressFail	include/catch.hpp	/^        SuppressFail = 0x08         \/\/ Failures are reported but do not fail the test$/;"	e	enum:Catch::ResultDisposition::Flags
Catch::ResultWas	include/catch.hpp	/^    struct ResultWas { enum OfType {$/;"	s	namespace:Catch
Catch::ResultWas::DidntThrowException	include/catch.hpp	/^        DidntThrowException = Exception | 2,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::Exception	include/catch.hpp	/^        Exception = 0x100 | FailureBit,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::ExplicitFailure	include/catch.hpp	/^        ExplicitFailure = FailureBit | 2,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::ExpressionFailed	include/catch.hpp	/^        ExpressionFailed = FailureBit | 1,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::FailureBit	include/catch.hpp	/^        FailureBit = 0x10,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::FatalErrorCondition	include/catch.hpp	/^        FatalErrorCondition = 0x200 | FailureBit$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::Info	include/catch.hpp	/^        Info = 1,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::OfType	include/catch.hpp	/^    struct ResultWas { enum OfType {$/;"	g	struct:Catch::ResultWas	access:public
Catch::ResultWas::Ok	include/catch.hpp	/^        Ok = 0,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::ThrewException	include/catch.hpp	/^        ThrewException = Exception | 1,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::Unknown	include/catch.hpp	/^        Unknown = -1,$/;"	e	enum:Catch::ResultWas::OfType
Catch::ResultWas::Warning	include/catch.hpp	/^        Warning = 2,$/;"	e	enum:Catch::ResultWas::OfType
Catch::SafeBool	include/catch.hpp	/^    class SafeBool {$/;"	c	namespace:Catch
Catch::SafeBool::makeSafe	include/catch.hpp	/^        static type makeSafe( bool value ) {$/;"	f	class:Catch::SafeBool	access:public	signature:( bool value )
Catch::SafeBool::trueValue	include/catch.hpp	/^        void trueValue() const {}$/;"	f	class:Catch::SafeBool	access:private	signature:() const
Catch::SharedImpl	include/catch.hpp	/^    struct SharedImpl : T {$/;"	s	namespace:Catch	inherits:T
Catch::SharedImpl::SharedImpl	include/catch.hpp	/^        SharedImpl() : m_rc( 0 ){}$/;"	f	struct:Catch::SharedImpl	access:public	signature:()
Catch::SharedImpl::addRef	include/catch.hpp	/^        virtual void addRef() const {$/;"	f	struct:Catch::SharedImpl	access:public	signature:() const
Catch::SharedImpl::m_rc	include/catch.hpp	/^        mutable unsigned int m_rc;$/;"	m	struct:Catch::SharedImpl	access:public
Catch::SharedImpl::release	include/catch.hpp	/^        virtual void release() const {$/;"	f	struct:Catch::SharedImpl	access:public	signature:() const
Catch::SourceLineInfo	include/catch.hpp	/^    struct SourceLineInfo {$/;"	s	namespace:Catch
Catch::SourceLineInfo::SourceLineInfo	include/catch.hpp	/^        SourceLineInfo( SourceLineInfo && )                  = default;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo && )
Catch::SourceLineInfo::SourceLineInfo	include/catch.hpp	/^        SourceLineInfo( SourceLineInfo const& other );$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& other )
Catch::SourceLineInfo::SourceLineInfo	include/catch.hpp	/^        SourceLineInfo( char const* _file, std::size_t _line );$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( char const* _file, std::size_t _line )
Catch::SourceLineInfo::SourceLineInfo	include/catch.hpp	/^        SourceLineInfo();$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:()
Catch::SourceLineInfo::empty	include/catch.hpp	/^        bool empty() const;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:() const
Catch::SourceLineInfo::file	include/catch.hpp	/^        std::string file;$/;"	m	struct:Catch::SourceLineInfo	access:public
Catch::SourceLineInfo::line	include/catch.hpp	/^        std::size_t line;$/;"	m	struct:Catch::SourceLineInfo	access:public
Catch::SourceLineInfo::operator <	include/catch.hpp	/^        bool operator < ( SourceLineInfo const& other ) const;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& other ) const
Catch::SourceLineInfo::operator =	include/catch.hpp	/^        SourceLineInfo& operator = ( SourceLineInfo && )     = default;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo && )
Catch::SourceLineInfo::operator =	include/catch.hpp	/^        SourceLineInfo& operator = ( SourceLineInfo const& ) = default;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& )
Catch::SourceLineInfo::operator ==	include/catch.hpp	/^        bool operator == ( SourceLineInfo const& other ) const;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& other ) const
Catch::StreamEndStop	include/catch.hpp	/^    struct StreamEndStop {$/;"	s	namespace:Catch
Catch::StreamEndStop::operator +	include/catch.hpp	/^        std::string operator+() {$/;"	f	struct:Catch::StreamEndStop	access:public	signature:()
Catch::StringMaker	include/catch.hpp	/^struct StringMaker :$/;"	s	namespace:Catch	inherits:Detail::StringMakerBase
Catch::StringMaker	include/catch.hpp	/^struct StringMaker<R C::*> {$/;"	s	namespace:Catch
Catch::StringMaker	include/catch.hpp	/^struct StringMaker<T*> {$/;"	s	namespace:Catch
Catch::StringMaker::convert	include/catch.hpp	/^    static std::string convert( R C::* p ) {$/;"	f	struct:Catch::StringMaker	access:public	signature:( R C::* p )
Catch::StringMaker::convert	include/catch.hpp	/^    static std::string convert( U* p ) {$/;"	f	struct:Catch::StringMaker	access:public	signature:( U* p )
Catch::TestFailureException	include/catch.hpp	/^    struct TestFailureException{};$/;"	s	namespace:Catch
Catch::TestFunction	include/catch.hpp	/^typedef void(*TestFunction)();$/;"	t	namespace:Catch
Catch::TupleDetail	include/catch.hpp	/^namespace TupleDetail {$/;"	n	namespace:Catch
Catch::alwaysFalse	include/catch.hpp	/^    inline bool alwaysFalse() { return false; }$/;"	f	namespace:Catch	signature:()
Catch::alwaysTrue	include/catch.hpp	/^    inline bool alwaysTrue() { return true; }$/;"	f	namespace:Catch	signature:()
Catch::cleanUpContext	include/catch.hpp	/^    void cleanUpContext();$/;"	p	namespace:Catch	signature:()
Catch::contains	include/catch.hpp	/^    bool contains( std::string const& s, std::string const& infix );$/;"	p	namespace:Catch	signature:( std::string const& s, std::string const& infix )
Catch::createGeneratorsForTest	include/catch.hpp	/^    IGeneratorsForTest* createGeneratorsForTest();$/;"	p	namespace:Catch	signature:()
Catch::createStream	include/catch.hpp	/^    Stream createStream( std::string const& streamName );$/;"	p	namespace:Catch	signature:( std::string const& streamName )
Catch::deleteAll	include/catch.hpp	/^    inline void deleteAll( ContainerT& container ) {$/;"	f	namespace:Catch	signature:( ContainerT& container )
Catch::deleteAllValues	include/catch.hpp	/^    inline void deleteAllValues( AssociativeContainerT& container ) {$/;"	f	namespace:Catch	signature:( AssociativeContainerT& container )
Catch::endsWith	include/catch.hpp	/^    bool endsWith( std::string const& s, std::string const& suffix );$/;"	p	namespace:Catch	signature:( std::string const& s, std::string const& suffix )
Catch::getCurrentContext	include/catch.hpp	/^    IContext& getCurrentContext();$/;"	p	namespace:Catch	signature:()
Catch::getCurrentMutableContext	include/catch.hpp	/^    IMutableContext& getCurrentMutableContext();$/;"	p	namespace:Catch	signature:()
Catch::isFalseTest	include/catch.hpp	/^    inline bool isFalseTest( int flags )                { return ( flags & ResultDisposition::FalseTest ) != 0; }$/;"	f	namespace:Catch	signature:( int flags )
Catch::isJustInfo	include/catch.hpp	/^    inline bool isJustInfo( int flags ) {$/;"	f	namespace:Catch	signature:( int flags )
Catch::isOk	include/catch.hpp	/^    inline bool isOk( ResultWas::OfType resultType ) {$/;"	f	namespace:Catch	signature:( ResultWas::OfType resultType )
Catch::isTrue	include/catch.hpp	/^    inline bool isTrue( bool value ){ return value; }$/;"	f	namespace:Catch	signature:( bool value )
Catch::operator +	include/catch.hpp	/^    T const& operator + ( T const& value, StreamEndStop ) {$/;"	f	namespace:Catch	signature:( T const& value, StreamEndStop )
Catch::operator <<	include/catch.hpp	/^    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );$/;"	p	namespace:Catch	signature:( std::ostream& os, SourceLineInfo const& info )
Catch::operator |	include/catch.hpp	/^    inline ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {$/;"	f	namespace:Catch	signature:( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs )
Catch::pluralise	include/catch.hpp	/^    struct pluralise {$/;"	s	namespace:Catch
Catch::pluralise::m_count	include/catch.hpp	/^        std::size_t m_count;$/;"	m	struct:Catch::pluralise	access:public
Catch::pluralise::m_label	include/catch.hpp	/^        std::string m_label;$/;"	m	struct:Catch::pluralise	access:public
Catch::pluralise::operator <<	include/catch.hpp	/^        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );$/;"	p	struct:Catch::pluralise	access:friend	signature:( std::ostream& os, pluralise const& pluraliser )
Catch::pluralise::pluralise	include/catch.hpp	/^        pluralise( std::size_t count, std::string const& label );$/;"	p	struct:Catch::pluralise	access:public	signature:( std::size_t count, std::string const& label )
Catch::replaceInPlace	include/catch.hpp	/^    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );$/;"	p	namespace:Catch	signature:( std::string& str, std::string const& replaceThis, std::string const& withThis )
Catch::shouldContinueOnFailure	include/catch.hpp	/^    inline bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }$/;"	f	namespace:Catch	signature:( int flags )
Catch::shouldSuppressFailure	include/catch.hpp	/^    inline bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }$/;"	f	namespace:Catch	signature:( int flags )
Catch::startsWith	include/catch.hpp	/^    bool startsWith( std::string const& s, std::string const& prefix );$/;"	p	namespace:Catch	signature:( std::string const& s, std::string const& prefix )
Catch::throwLogicError	include/catch.hpp	/^    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo );$/;"	p	namespace:Catch	signature:( std::string const& message, SourceLineInfo const& locationInfo )
Catch::toLower	include/catch.hpp	/^    std::string toLower( std::string const& s );$/;"	p	namespace:Catch	signature:( std::string const& s )
Catch::toLowerInPlace	include/catch.hpp	/^    void toLowerInPlace( std::string& s );$/;"	p	namespace:Catch	signature:( std::string& s )
Catch::toString	include/catch.hpp	/^    std::string toString( NSObject* const& nsObject );$/;"	p	namespace:Catch	signature:( NSObject* const& nsObject )
Catch::toString	include/catch.hpp	/^    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring );$/;"	p	namespace:Catch	signature:( NSString * CATCH_ARC_STRONG const& nsstring )
Catch::toString	include/catch.hpp	/^    std::string toString( NSString const * const& nsstring );$/;"	p	namespace:Catch	signature:( NSString const * const& nsstring )
Catch::toString	include/catch.hpp	/^std::string toString( T const& value );$/;"	p	namespace:Catch	signature:( T const& value )
Catch::toString	include/catch.hpp	/^std::string toString( bool value );$/;"	p	namespace:Catch	signature:( bool value )
Catch::toString	include/catch.hpp	/^std::string toString( char value );$/;"	p	namespace:Catch	signature:( char value )
Catch::toString	include/catch.hpp	/^std::string toString( char* const value );$/;"	p	namespace:Catch	signature:( char* const value )
Catch::toString	include/catch.hpp	/^std::string toString( const char* const value );$/;"	p	namespace:Catch	signature:( const char* const value )
Catch::toString	include/catch.hpp	/^std::string toString( const double value );$/;"	p	namespace:Catch	signature:( const double value )
Catch::toString	include/catch.hpp	/^std::string toString( const float value );$/;"	p	namespace:Catch	signature:( const float value )
Catch::toString	include/catch.hpp	/^std::string toString( const wchar_t* const value );$/;"	p	namespace:Catch	signature:( const wchar_t* const value )
Catch::toString	include/catch.hpp	/^std::string toString( int value );$/;"	p	namespace:Catch	signature:( int value )
Catch::toString	include/catch.hpp	/^std::string toString( signed char value );$/;"	p	namespace:Catch	signature:( signed char value )
Catch::toString	include/catch.hpp	/^std::string toString( std::nullptr_t );$/;"	p	namespace:Catch	signature:( std::nullptr_t )
Catch::toString	include/catch.hpp	/^std::string toString( std::string const& value );$/;"	p	namespace:Catch	signature:( std::string const& value )
Catch::toString	include/catch.hpp	/^std::string toString( std::vector<T,Allocator> const& v ) {$/;"	f	namespace:Catch	signature:( std::vector<T,Allocator> const& v )
Catch::toString	include/catch.hpp	/^std::string toString( std::wstring const& value );$/;"	p	namespace:Catch	signature:( std::wstring const& value )
Catch::toString	include/catch.hpp	/^std::string toString( unsigned char value );$/;"	p	namespace:Catch	signature:( unsigned char value )
Catch::toString	include/catch.hpp	/^std::string toString( unsigned int value );$/;"	p	namespace:Catch	signature:( unsigned int value )
Catch::toString	include/catch.hpp	/^std::string toString( unsigned long value );$/;"	p	namespace:Catch	signature:( unsigned long value )
Catch::toString	include/catch.hpp	/^std::string toString( wchar_t* const value );$/;"	p	namespace:Catch	signature:( wchar_t* const value )
Catch::trim	include/catch.hpp	/^    std::string trim( std::string const& str );$/;"	p	namespace:Catch	signature:( std::string const& str )
ContinueOnFailure	include/catch.hpp	/^        ContinueOnFailure = 0x02,   \/\/ Failures fail test, but execution continues$/;"	e	enum:Catch::ResultDisposition::Flags
CopyableStream	include/catch.hpp	/^        CopyableStream( CopyableStream const& other ) {$/;"	f	struct:Catch::CopyableStream	access:public	signature:( CopyableStream const& other )
CopyableStream	include/catch.hpp	/^        CopyableStream() {}$/;"	f	struct:Catch::CopyableStream	access:public	signature:()
CopyableStream	include/catch.hpp	/^    struct CopyableStream {$/;"	s	namespace:Catch
CreateWindow	src/main.cpp	/^static GLFWwindow* CreateWindow(){$/;"	f	file:	signature:()
Detail	include/catch.hpp	/^namespace Detail {$/;"	n	namespace:Catch
DidntThrowException	include/catch.hpp	/^        DidntThrowException = Exception | 2,$/;"	e	enum:Catch::ResultWas::OfType
EnumStringMaker	include/catch.hpp	/^    struct EnumStringMaker$/;"	s	namespace:Catch::Detail
EnumStringMaker	include/catch.hpp	/^    struct EnumStringMaker<T,true>$/;"	s	namespace:Catch::Detail
Evaluator	include/catch.hpp	/^    class Evaluator{};$/;"	c	namespace:Catch::Internal
Evaluator	include/catch.hpp	/^    struct Evaluator<T1, T2, IsEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	include/catch.hpp	/^    struct Evaluator<T1, T2, IsGreaterThan> {$/;"	s	namespace:Catch::Internal
Evaluator	include/catch.hpp	/^    struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	include/catch.hpp	/^    struct Evaluator<T1, T2, IsLessThan> {$/;"	s	namespace:Catch::Internal
Evaluator	include/catch.hpp	/^    struct Evaluator<T1, T2, IsLessThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	include/catch.hpp	/^    struct Evaluator<T1, T2, IsNotEqualTo> {$/;"	s	namespace:Catch::Internal
Exception	include/catch.hpp	/^        Exception = 0x100 | FailureBit,$/;"	e	enum:Catch::ResultWas::OfType
ExplicitFailure	include/catch.hpp	/^        ExplicitFailure = FailureBit | 2,$/;"	e	enum:Catch::ResultWas::OfType
ExprComponents	include/catch.hpp	/^            ExprComponents() : testFalse( false ) {}$/;"	f	struct:Catch::ResultBuilder::ExprComponents	access:public	signature:()
ExprComponents	include/catch.hpp	/^        struct ExprComponents {$/;"	s	class:Catch::ResultBuilder	access:private
ExpressionFailed	include/catch.hpp	/^        ExpressionFailed = FailureBit | 1,$/;"	e	enum:Catch::ResultWas::OfType
FACADELINE_H	src/headers/facade/line.h	2;"	d
Facade	src/headers/facade/line.h	/^namespace Facade{$/;"	n
Facade::Line	src/headers/facade/line.h	/^	class Line{$/;"	c	namespace:Facade
FailureBit	include/catch.hpp	/^        FailureBit = 0x10,$/;"	e	enum:Catch::ResultWas::OfType
FalseTest	include/catch.hpp	/^        FalseTest = 0x04,           \/\/ Prefix expression with !$/;"	e	enum:Catch::ResultDisposition::Flags
FalseType	include/catch.hpp	/^    struct FalseType { char sizer[2]; };$/;"	s	namespace:Catch::Detail
FatalErrorCondition	include/catch.hpp	/^        FatalErrorCondition = 0x200 | FailureBit$/;"	e	enum:Catch::ResultWas::OfType
Flags	include/catch.hpp	/^    struct ResultDisposition { enum Flags {$/;"	g	struct:Catch::ResultDisposition	access:public
GAMEFACADE_H	src/headers/gamefacade.h	2;"	d
GEOMETRYLINE_H	src/headers/geometry/line.h	2;"	d
GEOMETRYPOINT_H	src/headers/geometry/point.h	2;"	d
GIVEN	include/catch.hpp	9393;"	d
GLDEBUG_H	src/headers/gldebug.h	2;"	d
GRIDGEOMETRY_H	src/headers/GridGeometry.cpp	18;"	d	file:
GameFacade	src/headers/gamefacade.h	/^		GameFacade();$/;"	p	class:GameFacade	access:protected	signature:()
GameFacade	src/headers/gamefacade.h	/^class GameFacade {$/;"	c
GameFacade::GameFacade	src/headers/gamefacade.h	/^		GameFacade();$/;"	p	class:GameFacade	access:protected	signature:()
GameFacade::_instance	src/headers/gamefacade.h	/^		static GameFacade* _instance;$/;"	m	class:GameFacade	access:private
GameFacade::createLine	src/headers/gamefacade.h	/^		Facade::Line* createLine(Geometry::Line line);$/;"	p	class:GameFacade	access:public	signature:(Geometry::Line line)
GameFacade::instance	src/headers/gamefacade.h	/^		static GameFacade* instance();$/;"	p	class:GameFacade	access:public	signature:()
GameFacade::~GameFacade	src/headers/gamefacade.h	/^		~GameFacade();$/;"	p	class:GameFacade	access:protected	signature:()
Geometry	src/headers/geometry/line.h	/^namespace Geometry{$/;"	n
Geometry	src/headers/geometry/point.h	/^namespace Geometry{$/;"	n
Geometry::Line	src/headers/geometry/line.h	/^	class Line{$/;"	c	namespace:Geometry
Geometry::Line::Line	src/headers/geometry/line.h	/^			Line();$/;"	p	class:Geometry::Line	access:public	signature:()
Geometry::Line::Line	src/headers/geometry/line.h	/^			Line(Point a, Point b);$/;"	p	class:Geometry::Line	access:public	signature:(Point a, Point b)
Geometry::Line::~Line	src/headers/geometry/line.h	/^			~Line();$/;"	p	class:Geometry::Line	access:public	signature:()
Geometry::Point	src/headers/geometry/point.h	/^class Point{$/;"	c	namespace:Geometry
Geometry::Point::Point	src/headers/geometry/point.h	/^		Point(float x, float y, float z);$/;"	p	class:Geometry::Point	access:public	signature:(float x, float y, float z)
Geometry::Point::~Point	src/headers/geometry/point.h	/^		~Point();$/;"	p	class:Geometry::Point	access:public	signature:()
GridGeometry.cpp	src/headers/GridGeometry.cpp	1;"	F
GridGeomtry	src/headers/GridGeometry.cpp	/^		GridGeomtry(int width, int height, int rows, int columns);$/;"	p	class:GridGeomtry	file:	access:public	signature:(int width, int height, int rows, int columns)
GridGeomtry	src/headers/GridGeometry.cpp	/^class GridGeomtry{$/;"	c	file:
GridGeomtry::GridGeomtry	src/headers/GridGeometry.cpp	/^		GridGeomtry(int width, int height, int rows, int columns);$/;"	p	class:GridGeomtry	file:	access:public	signature:(int width, int height, int rows, int columns)
GridGeomtry::columns	src/headers/GridGeometry.cpp	/^		int columns;$/;"	m	class:GridGeomtry	file:	access:private
GridGeomtry::generate	src/headers/GridGeometry.cpp	/^		int* generate();$/;"	p	class:GridGeomtry	file:	access:public	signature:()
GridGeomtry::height	src/headers/GridGeometry.cpp	/^		int height;$/;"	m	class:GridGeomtry	file:	access:private
GridGeomtry::points	src/headers/GridGeometry.cpp	/^		int* points;$/;"	m	class:GridGeomtry	file:	access:private
GridGeomtry::rows	src/headers/GridGeometry.cpp	/^		int rows;$/;"	m	class:GridGeomtry	file:	access:private
GridGeomtry::width	src/headers/GridGeometry.cpp	/^		int width;$/;"	m	class:GridGeomtry	file:	access:private
GridGeomtry::~GridGeomtry	src/headers/GridGeometry.cpp	/^		~GridGeomtry();$/;"	p	class:GridGeomtry	file:	access:public	signature:()
IContext	include/catch.hpp	/^    struct IContext$/;"	s	namespace:Catch
IGeneratorInfo	include/catch.hpp	/^    struct IGeneratorInfo {$/;"	s	namespace:Catch
IGeneratorsForTest	include/catch.hpp	/^    struct IGeneratorsForTest {$/;"	s	namespace:Catch
IMutableContext	include/catch.hpp	/^    struct IMutableContext : IContext$/;"	s	namespace:Catch	inherits:IContext
INTERNAL_CATCH_ELSE	include/catch.hpp	1588;"	d
INTERNAL_CATCH_GENERATE	include/catch.hpp	2009;"	d
INTERNAL_CATCH_IF	include/catch.hpp	1583;"	d
INTERNAL_CATCH_INFO	include/catch.hpp	1663;"	d
INTERNAL_CATCH_LINESTR	include/catch.hpp	2007;"	d
INTERNAL_CATCH_LINESTR2	include/catch.hpp	2006;"	d
INTERNAL_CATCH_METHOD_AS_TEST_CASE	include/catch.hpp	605;"	d
INTERNAL_CATCH_MSG	include/catch.hpp	1645;"	d
INTERNAL_CATCH_NO_THROW	include/catch.hpp	1593;"	d
INTERNAL_CATCH_REACT	include/catch.hpp	1565;"	d
INTERNAL_CATCH_REGISTER_LEGACY_REPORTER	include/catch.hpp	7850;"	d
INTERNAL_CATCH_REGISTER_REPORTER	include/catch.hpp	7852;"	d
INTERNAL_CATCH_SECTION	include/catch.hpp	1824;"	d
INTERNAL_CATCH_STRINGIFY	include/catch.hpp	70;"	d
INTERNAL_CATCH_STRINGIFY2	include/catch.hpp	69;"	d
INTERNAL_CATCH_TEST	include/catch.hpp	1570;"	d
INTERNAL_CATCH_TESTCASE	include/catch.hpp	599;"	d
INTERNAL_CATCH_TEST_CASE_METHOD	include/catch.hpp	609;"	d
INTERNAL_CATCH_THROWS	include/catch.hpp	1607;"	d
INTERNAL_CATCH_THROWS_AS	include/catch.hpp	1624;"	d
INTERNAL_CATCH_TRANSLATE_EXCEPTION	include/catch.hpp	2099;"	d
INTERNAL_CATCH_UNIQUE_NAME	include/catch.hpp	67;"	d
INTERNAL_CATCH_UNIQUE_NAME_LINE	include/catch.hpp	66;"	d
INTERNAL_CATCH_UNIQUE_NAME_LINE2	include/catch.hpp	65;"	d
INTERNAL_CHECK_THAT	include/catch.hpp	1667;"	d
IShared	include/catch.hpp	/^    struct IShared : NonCopyable {$/;"	s	namespace:Catch	inherits:NonCopyable
ITestCase	include/catch.hpp	/^    struct ITestCase : IShared {$/;"	s	namespace:Catch	inherits:IShared
ITestCaseRegistry	include/catch.hpp	/^    struct ITestCaseRegistry {$/;"	s	namespace:Catch
Info	include/catch.hpp	/^        Info = 1,$/;"	e	enum:Catch::ResultWas::OfType
Instance	src/headers/VisualServer.h	/^		static VisualServer* Instance();$/;"	p	class:VisualServer	access:public	signature:()
Internal	include/catch.hpp	/^namespace Internal {$/;"	n	namespace:Catch
IsEqualTo	include/catch.hpp	/^        IsEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsGreaterThan	include/catch.hpp	/^        IsGreaterThan,$/;"	e	enum:Catch::Internal::Operator
IsGreaterThanOrEqualTo	include/catch.hpp	/^        IsGreaterThanOrEqualTo$/;"	e	enum:Catch::Internal::Operator
IsLessThan	include/catch.hpp	/^        IsLessThan,$/;"	e	enum:Catch::Internal::Operator
IsLessThanOrEqualTo	include/catch.hpp	/^        IsLessThanOrEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsNotEqualTo	include/catch.hpp	/^        IsNotEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsStreamInsertable	include/catch.hpp	/^    struct IsStreamInsertable {$/;"	s	namespace:Catch::Detail
Line	src/headers/facade/line.h	/^	class Line{$/;"	c	namespace:Facade
Line	src/headers/geometry/line.h	/^			Line();$/;"	p	class:Geometry::Line	access:public	signature:()
Line	src/headers/geometry/line.h	/^			Line(Point a, Point b);$/;"	p	class:Geometry::Line	access:public	signature:(Point a, Point b)
Line	src/headers/geometry/line.h	/^	class Line{$/;"	c	namespace:Geometry
LinkedMatrix	src/matrixstacksingleton.cpp	/^struct LinkedMatrix{$/;"	s	file:
LinkedMatrix::me	src/matrixstacksingleton.cpp	/^	glm::mat4 me;$/;"	m	struct:LinkedMatrix	file:	access:public
LinkedMatrix::prev	src/matrixstacksingleton.cpp	/^	struct LinkedMatrix* prev;$/;"	m	struct:LinkedMatrix	typeref:struct:LinkedMatrix::LinkedMatrix	file:	access:public
MATRIXSTACKSINGLETON_H	src/headers/matrixstacksingleton.h	2;"	d
MatrixStackSingleton	src/headers/matrixstacksingleton.h	/^		MatrixStackSingleton();$/;"	p	class:MatrixStackSingleton	access:protected	signature:()
MatrixStackSingleton	src/headers/matrixstacksingleton.h	/^class MatrixStackSingleton{$/;"	c
MatrixStackSingleton	src/matrixstacksingleton.cpp	/^MatrixStackSingleton::MatrixStackSingleton(){$/;"	f	class:MatrixStackSingleton	signature:()
MatrixStackSingleton::MatrixStackSingleton	src/headers/matrixstacksingleton.h	/^		MatrixStackSingleton();$/;"	p	class:MatrixStackSingleton	access:protected	signature:()
MatrixStackSingleton::MatrixStackSingleton	src/matrixstacksingleton.cpp	/^MatrixStackSingleton::MatrixStackSingleton(){$/;"	f	class:MatrixStackSingleton	signature:()
MatrixStackSingleton::_instance	src/headers/matrixstacksingleton.h	/^		static MatrixStackSingleton* _instance;$/;"	m	class:MatrixStackSingleton	access:private
MatrixStackSingleton::_instance	src/matrixstacksingleton.cpp	/^MatrixStackSingleton* MatrixStackSingleton::_instance = 0;$/;"	m	class:MatrixStackSingleton	file:
MatrixStackSingleton::instance	src/headers/matrixstacksingleton.h	/^		static MatrixStackSingleton* instance();$/;"	p	class:MatrixStackSingleton	access:public	signature:()
MatrixStackSingleton::instance	src/matrixstacksingleton.cpp	/^MatrixStackSingleton* MatrixStackSingleton::instance(){$/;"	f	class:MatrixStackSingleton	signature:()
MatrixStackSingleton::pop	src/headers/matrixstacksingleton.h	/^		glm::mat4 pop();$/;"	p	class:MatrixStackSingleton	access:public	signature:()
MatrixStackSingleton::pop	src/matrixstacksingleton.cpp	/^glm::mat4 MatrixStackSingleton::pop(){$/;"	f	class:MatrixStackSingleton	signature:()
MatrixStackSingleton::push	src/headers/matrixstacksingleton.h	/^		glm::mat4 push(glm::mat4 m);$/;"	p	class:MatrixStackSingleton	access:public	signature:(glm::mat4 m)
MatrixStackSingleton::push	src/matrixstacksingleton.cpp	/^glm::mat4 MatrixStackSingleton::push(glm::mat4 m){$/;"	f	class:MatrixStackSingleton	signature:(glm::mat4 m)
MatrixStackSingleton::~MatrixStackSingleton	src/headers/matrixstacksingleton.h	/^		~MatrixStackSingleton();$/;"	p	class:MatrixStackSingleton	access:protected	signature:()
MatrixStackSingleton::~MatrixStackSingleton	src/matrixstacksingleton.cpp	/^MatrixStackSingleton::~MatrixStackSingleton(){$/;"	f	class:MatrixStackSingleton	signature:()
MethodTestCase	include/catch.hpp	/^    MethodTestCase( void (C::*method)() ) : m_method( method ) {}$/;"	f	class:Catch::MethodTestCase	access:public	signature:( void (C::*method)() )
MethodTestCase	include/catch.hpp	/^class MethodTestCase : public SharedImpl<ITestCase> {$/;"	c	namespace:Catch	inherits:SharedImpl
NOMINMAX	include/catch.hpp	6271;"	d
NameAndDesc	include/catch.hpp	/^    NameAndDesc( const char* _name = "", const char* _description= "" )$/;"	f	struct:Catch::NameAndDesc	access:public	signature:( const char* _name = Ó, const char* _description= Ó )
NameAndDesc	include/catch.hpp	/^struct NameAndDesc {$/;"	s	namespace:Catch
NonCopyable	include/catch.hpp	/^        NonCopyable( NonCopyable && )                  = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable && )
NonCopyable	include/catch.hpp	/^        NonCopyable( NonCopyable const& )              = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable const& )
NonCopyable	include/catch.hpp	/^        NonCopyable() {}$/;"	f	class:Catch::NonCopyable	access:protected	signature:()
NonCopyable	include/catch.hpp	/^    class NonCopyable {$/;"	c	namespace:Catch
Normal	include/catch.hpp	/^        Normal = 0x01,$/;"	e	enum:Catch::ResultDisposition::Flags
NotImplementedException	include/catch.hpp	/^        NotImplementedException( NotImplementedException const& ) {}$/;"	f	class:Catch::NotImplementedException	access:public	signature:( NotImplementedException const& )
NotImplementedException	include/catch.hpp	/^        NotImplementedException( SourceLineInfo const& lineInfo );$/;"	p	class:Catch::NotImplementedException	access:public	signature:( SourceLineInfo const& lineInfo )
NotImplementedException	include/catch.hpp	/^    class NotImplementedException : public std::exception$/;"	c	namespace:Catch	inherits:std::exception
OC_TEST_CASE	include/catch.hpp	2774;"	d
OfType	include/catch.hpp	/^    struct ResultWas { enum OfType {$/;"	g	struct:Catch::ResultWas	access:public
Ok	include/catch.hpp	/^        Ok = 0,$/;"	e	enum:Catch::ResultWas::OfType
Operator	include/catch.hpp	/^    enum Operator {$/;"	g	namespace:Catch::Internal
OperatorTraits	include/catch.hpp	/^    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	include/catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	include/catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	include/catch.hpp	/^    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	include/catch.hpp	/^    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	include/catch.hpp	/^    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	include/catch.hpp	/^    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };$/;"	s	namespace:Catch::Internal
Point	src/headers/geometry/point.h	/^		Point(float x, float y, float z);$/;"	p	class:Geometry::Point	access:public	signature:(float x, float y, float z)
Point	src/headers/geometry/point.h	/^class Point{$/;"	c	namespace:Geometry
Ptr	include/catch.hpp	/^        Ptr( Ptr const& other ) : m_p( other.m_p ){$/;"	f	class:Catch::Ptr	access:public	signature:( Ptr const& other )
Ptr	include/catch.hpp	/^        Ptr( T* p ) : m_p( p ){$/;"	f	class:Catch::Ptr	access:public	signature:( T* p )
Ptr	include/catch.hpp	/^        Ptr() : m_p( NULL ){}$/;"	f	class:Catch::Ptr	access:public	signature:()
Ptr	include/catch.hpp	/^    class Ptr {$/;"	c	namespace:Catch
ResultBuilder	include/catch.hpp	/^        ResultBuilder(  char const* macroName,$/;"	p	class:Catch::ResultBuilder	access:public	signature:( char const* macroName, SourceLineInfo const& lineInfo, char const* capturedExpression, ResultDisposition::Flags resultDisposition )
ResultBuilder	include/catch.hpp	/^    class ResultBuilder {$/;"	c	namespace:Catch
ResultDisposition	include/catch.hpp	/^    struct ResultDisposition { enum Flags {$/;"	s	namespace:Catch
ResultWas	include/catch.hpp	/^    struct ResultWas { enum OfType {$/;"	s	namespace:Catch
SCENARIO	include/catch.hpp	9387;"	d
SCENARIO_METHOD	include/catch.hpp	9388;"	d
STITCH_CLARA_CLOSE_NAMESPACE	include/catch.hpp	3277;"	d
STITCH_CLARA_CLOSE_NAMESPACE	include/catch.hpp	4114;"	d
STITCH_CLARA_OPEN_NAMESPACE	include/catch.hpp	3268;"	d
STITCH_CLARA_OPEN_NAMESPACE	include/catch.hpp	3276;"	d
STITCH_CLARA_OPEN_NAMESPACE	include/catch.hpp	4113;"	d
STITCH_CLARA_OPEN_NAMESPACE	include/catch.hpp	4117;"	d
STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE	include/catch.hpp	3282;"	d
STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE	include/catch.hpp	3431;"	d
SafeBool	include/catch.hpp	/^    class SafeBool {$/;"	c	namespace:Catch
SharedImpl	include/catch.hpp	/^        SharedImpl() : m_rc( 0 ){}$/;"	f	struct:Catch::SharedImpl	access:public	signature:()
SharedImpl	include/catch.hpp	/^    struct SharedImpl : T {$/;"	s	namespace:Catch	inherits:T
SourceLineInfo	include/catch.hpp	/^        SourceLineInfo( SourceLineInfo && )                  = default;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo && )
SourceLineInfo	include/catch.hpp	/^        SourceLineInfo( SourceLineInfo const& other );$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& other )
SourceLineInfo	include/catch.hpp	/^        SourceLineInfo( char const* _file, std::size_t _line );$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( char const* _file, std::size_t _line )
SourceLineInfo	include/catch.hpp	/^        SourceLineInfo();$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:()
SourceLineInfo	include/catch.hpp	/^    struct SourceLineInfo {$/;"	s	namespace:Catch
StreamEndStop	include/catch.hpp	/^    struct StreamEndStop {$/;"	s	namespace:Catch
StringMaker	include/catch.hpp	/^struct StringMaker :$/;"	s	namespace:Catch	inherits:Detail::StringMakerBase
StringMaker	include/catch.hpp	/^struct StringMaker<R C::*> {$/;"	s	namespace:Catch
StringMaker	include/catch.hpp	/^struct StringMaker<T*> {$/;"	s	namespace:Catch
StringMakerBase	include/catch.hpp	/^    struct StringMakerBase {$/;"	s	namespace:Catch::Detail
StringMakerBase	include/catch.hpp	/^    struct StringMakerBase<true> {$/;"	s	namespace:Catch::Detail
SuppressFail	include/catch.hpp	/^        SuppressFail = 0x08         \/\/ Failures are reported but do not fail the test$/;"	e	enum:Catch::ResultDisposition::Flags
TBC_TEXT_FORMAT_CONSOLE_WIDTH	include/catch.hpp	4298;"	d
TBC_TEXT_FORMAT_H_INCLUDED	include/catch.hpp	3289;"	d
THEN	include/catch.hpp	9396;"	d
TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED	include/catch.hpp	2105;"	d
TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED	include/catch.hpp	6481;"	d
TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED	include/catch.hpp	700;"	d
TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED	include/catch.hpp	642;"	d
TWOBLUECUBES_CATCH_CLARA_H_INCLUDED	include/catch.hpp	3258;"	d
TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED	include/catch.hpp	2803;"	d
TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED	include/catch.hpp	6988;"	d
TWOBLUECUBES_CATCH_COMMON_H_INCLUDED	include/catch.hpp	63;"	d
TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED	include/catch.hpp	77;"	d
TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED	include/catch.hpp	2806;"	d
TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED	include/catch.hpp	4456;"	d
TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED	include/catch.hpp	6238;"	d
TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED	include/catch.hpp	358;"	d
TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED	include/catch.hpp	6046;"	d
TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED	include/catch.hpp	7113;"	d
TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED	include/catch.hpp	1500;"	d
TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED	include/catch.hpp	9228;"	d
TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED	include/catch.hpp	841;"	d
TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED	include/catch.hpp	5893;"	d
TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED	include/catch.hpp	838;"	d
TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED	include/catch.hpp	5066;"	d
TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED	include/catch.hpp	1832;"	d
TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED	include/catch.hpp	6407;"	d
TWOBLUECUBES_CATCH_HPP_INCLUDED	include/catch.hpp	14;"	d
TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED	include/catch.hpp	2789;"	d
TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED	include/catch.hpp	1465;"	d
TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED	include/catch.hpp	3031;"	d
TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED	include/catch.hpp	2012;"	d
TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED	include/catch.hpp	361;"	d
TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED	include/catch.hpp	2016;"	d
TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED	include/catch.hpp	4513;"	d
TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED	include/catch.hpp	1549;"	d
TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED	include/catch.hpp	2411;"	d
TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED	include/catch.hpp	511;"	d
TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED	include/catch.hpp	6810;"	d
TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED	include/catch.hpp	6813;"	d
TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED	include/catch.hpp	4293;"	d
TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED	include/catch.hpp	2186;"	d
TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED	include/catch.hpp	6775;"	d
TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED	include/catch.hpp	1409;"	d
TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED	include/catch.hpp	6025;"	d
TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED	include/catch.hpp	60;"	d
TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED	include/catch.hpp	1022;"	d
TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED	include/catch.hpp	2595;"	d
TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED	include/catch.hpp	2435;"	d
TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED	include/catch.hpp	1503;"	d
TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED	include/catch.hpp	385;"	d
TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED	include/catch.hpp	9403;"	d
TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED	include/catch.hpp	5705;"	d
TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED	include/catch.hpp	7583;"	d
TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED	include/catch.hpp	8884;"	d
TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED	include/catch.hpp	8447;"	d
TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED	include/catch.hpp	8234;"	d
TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED	include/catch.hpp	7793;"	d
TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED	include/catch.hpp	5858;"	d
TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED	include/catch.hpp	7580;"	d
TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED	include/catch.hpp	7375;"	d
TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED	include/catch.hpp	645;"	d
TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED	include/catch.hpp	648;"	d
TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED	include/catch.hpp	2800;"	d
TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED	include/catch.hpp	4923;"	d
TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED	include/catch.hpp	7080;"	d
TWOBLUECUBES_CATCH_SECTION_H_INCLUDED	include/catch.hpp	1685;"	d
TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED	include/catch.hpp	1688;"	d
TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED	include/catch.hpp	6052;"	d
TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED	include/catch.hpp	6049;"	d
TWOBLUECUBES_CATCH_STREAM_H_INCLUDED	include/catch.hpp	3084;"	d
TWOBLUECUBES_CATCH_SUPPRESS_WARNINGS_H_INCLUDED	include/catch.hpp	24;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED	include/catch.hpp	2414;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED	include/catch.hpp	7488;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED	include/catch.hpp	7491;"	d
TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED	include/catch.hpp	6561;"	d
TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED	include/catch.hpp	2514;"	d
TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED	include/catch.hpp	5708;"	d
TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED	include/catch.hpp	4926;"	d
TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED	include/catch.hpp	508;"	d
TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED	include/catch.hpp	2817;"	d
TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED	include/catch.hpp	2809;"	d
TWOBLUECUBES_CATCH_TEXT_H_INCLUDED	include/catch.hpp	4296;"	d
TWOBLUECUBES_CATCH_TIMER_H_INCLUDED	include/catch.hpp	1776;"	d
TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED	include/catch.hpp	7202;"	d
TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED	include/catch.hpp	1012;"	d
TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED	include/catch.hpp	1706;"	d
TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED	include/catch.hpp	6741;"	d
TWOBLUECUBES_CATCH_VERSION_H_INCLUDED	include/catch.hpp	5473;"	d
TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED	include/catch.hpp	7856;"	d
TWOBLUECUBES_CLARA_H_INCLUDED	include/catch.hpp	3275;"	d
TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED	include/catch.hpp	12;"	d
TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED	include/catch.hpp	4306;"	d
TestFailureException	include/catch.hpp	/^    struct TestFailureException{};$/;"	s	namespace:Catch
TestFunction	include/catch.hpp	/^typedef void(*TestFunction)();$/;"	t	namespace:Catch
ThrewException	include/catch.hpp	/^        ThrewException = Exception | 1,$/;"	e	enum:Catch::ResultWas::OfType
TrueType	include/catch.hpp	/^    struct TrueType { char sizer[1]; };$/;"	s	namespace:Catch::Detail
TupleDetail	include/catch.hpp	/^namespace TupleDetail {$/;"	n	namespace:Catch
Unknown	include/catch.hpp	/^        Unknown = -1,$/;"	e	enum:Catch::ResultWas::OfType
VISUALGRID	src/headers/GridGeometry.cpp	2;"	d	file:
VISUALSERVER_H	src/headers/VisualServer.h	2;"	d
VisualGrid	src/headers/GridGeometry.cpp	/^class VisualGrid{$/;"	c	file:
VisualGrid::WeldPoints	src/headers/GridGeometry.cpp	/^		int* WeldPoints(int* points);$/;"	p	class:VisualGrid	file:	access:public	signature:(int* points)
VisualGrid::indexCount	src/headers/GridGeometry.cpp	/^		int indexCount;$/;"	m	class:VisualGrid	file:	access:private
VisualGrid::indices	src/headers/GridGeometry.cpp	/^		int* indices;$/;"	m	class:VisualGrid	file:	access:private
VisualGrid::prepRender	src/headers/GridGeometry.cpp	/^		int* prepRender();$/;"	p	class:VisualGrid	file:	access:public	signature:()
VisualGrid::render	src/headers/GridGeometry.cpp	/^		void render(int vertexAttributeIndex);$/;"	p	class:VisualGrid	file:	access:public	signature:(int vertexAttributeIndex)
VisualServer	src/headers/VisualServer.h	/^		VisualServer();$/;"	p	class:VisualServer	access:protected	signature:()
VisualServer	src/headers/VisualServer.h	/^class VisualServer{$/;"	c
VisualServer.h	src/headers/VisualServer.h	1;"	F
VisualServer::Instance	src/headers/VisualServer.h	/^		static VisualServer* Instance();$/;"	p	class:VisualServer	access:public	signature:()
VisualServer::VisualServer	src/headers/VisualServer.h	/^		VisualServer();$/;"	p	class:VisualServer	access:protected	signature:()
VisualServer::_instance	src/headers/VisualServer.h	/^		static VisualServer* _instance;$/;"	m	class:VisualServer	access:private
WHEN	include/catch.hpp	9394;"	d
WINDOW_H	src/headers/window.h	2;"	d
Warning	include/catch.hpp	/^        Warning = 2,$/;"	e	enum:Catch::ResultWas::OfType
WeldPoints	src/headers/GridGeometry.cpp	/^		int* WeldPoints(int* points);$/;"	p	class:VisualGrid	file:	access:public	signature:(int* points)
Window	src/headers/window.h	/^	Window();$/;"	p	class:Window	access:public	signature:()
Window	src/headers/window.h	/^class Window{$/;"	c
Window	src/window.cpp	/^Window::Window(){$/;"	f	class:Window	signature:()
Window::Window	src/headers/window.h	/^	Window();$/;"	p	class:Window	access:public	signature:()
Window::Window	src/window.cpp	/^Window::Window(){$/;"	f	class:Window	signature:()
Window::create	src/headers/window.h	/^	bool create();$/;"	p	class:Window	access:public	signature:()
Window::height	src/headers/window.h	/^	int height;$/;"	m	class:Window	access:public
Window::shouldClose	src/headers/window.h	/^	bool shouldClose();$/;"	p	class:Window	access:public	signature:()
Window::title	src/headers/window.h	/^	char *title;$/;"	m	class:Window	access:public
Window::width	src/headers/window.h	/^	int width;$/;"	m	class:Window	access:public
Window::window	src/headers/window.h	/^		GLFWwindow *window;$/;"	m	class:Window	access:private
Window::~Window	src/headers/window.h	/^	virtual ~Window();$/;"	p	class:Window	access:public	signature:()
Window::~Window	src/window.cpp	/^Window::~Window(){$/;"	f	class:Window	signature:()
_head	src/matrixstacksingleton.cpp	/^struct LinkedMatrix* _head;$/;"	v	typeref:struct:LinkedMatrix
_instance	src/headers/VisualServer.h	/^		static VisualServer* _instance;$/;"	m	class:VisualServer	access:private
_instance	src/headers/gamefacade.h	/^		static GameFacade* _instance;$/;"	m	class:GameFacade	access:private
_instance	src/headers/matrixstacksingleton.h	/^		static MatrixStackSingleton* _instance;$/;"	m	class:MatrixStackSingleton	access:private
_instance	src/matrixstacksingleton.cpp	/^MatrixStackSingleton* MatrixStackSingleton::_instance = 0;$/;"	m	class:MatrixStackSingleton	file:
addRef	include/catch.hpp	/^        virtual void addRef() const = 0;$/;"	p	struct:Catch::IShared	access:public	signature:() const
addRef	include/catch.hpp	/^        virtual void addRef() const {$/;"	f	struct:Catch::SharedImpl	access:public	signature:() const
advanceGeneratorsForCurrentTest	include/catch.hpp	/^        virtual bool advanceGeneratorsForCurrentTest() = 0;$/;"	p	struct:Catch::IContext	access:public	signature:()
allowThrows	include/catch.hpp	/^        bool allowThrows() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
alwaysFalse	include/catch.hpp	/^    inline bool alwaysFalse() { return false; }$/;"	f	namespace:Catch	signature:()
alwaysTrue	include/catch.hpp	/^    inline bool alwaysTrue() { return true; }$/;"	f	namespace:Catch	signature:()
applyEvaluator	include/catch.hpp	/^    bool applyEvaluator( T1 const& lhs, T2 const& rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T1 const& lhs, T2 const& rhs )
arcSafeRelease	include/catch.hpp	/^inline void arcSafeRelease( NSObject* ){}$/;"	f	signature:( NSObject* )
arcSafeRelease	include/catch.hpp	/^inline void arcSafeRelease( NSObject* obj ) {$/;"	f	signature:( NSObject* obj )
arcSafeRelease	include/catch.hpp	/^void arcSafeRelease( NSObject* obj );$/;"	p	signature:( NSObject* obj )
aspect_ratio	src/main.cpp	/^static GLfloat aspect_ratio = 4.0f\/3.0f;$/;"	v	file:
build	include/catch.hpp	/^        AssertionResult build() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
build_from_tmux.sh	build_from_tmux.sh	1;"	F
captureExpression	include/catch.hpp	/^        void captureExpression();$/;"	p	class:Catch::ResultBuilder	access:public	signature:()
captureResult	include/catch.hpp	/^        void captureResult( ResultWas::OfType resultType );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( ResultWas::OfType resultType )
capturedExpression	include/catch.hpp	/^        std::string capturedExpression;$/;"	m	struct:Catch::AssertionInfo	access:public
catch.hpp	include/catch.hpp	1;"	F
check_error	src/main.cpp	/^static void check_error(){$/;"	f	file:	signature:()
cleanUpContext	include/catch.hpp	/^    void cleanUpContext();$/;"	p	namespace:Catch	signature:()
columns	src/headers/GridGeometry.cpp	/^		int columns;$/;"	m	class:GridGeomtry	file:	access:private
compare	include/catch.hpp	/^    bool compare( T1 const& lhs, T2 const& rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T1 const& lhs, T2 const& rhs )
compare	include/catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, int rhs )
compare	include/catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, long rhs )
compare	include/catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, std::nullptr_t ) {$/;"	f	namespace:Catch::Internal	signature:( T* lhs, std::nullptr_t )
compare	include/catch.hpp	/^    template<Operator Op, typename T> bool compare( int lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, T* rhs )
compare	include/catch.hpp	/^    template<Operator Op, typename T> bool compare( long lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, T* rhs )
compare	include/catch.hpp	/^    template<Operator Op, typename T> bool compare( std::nullptr_t, T* rhs ) {$/;"	f	namespace:Catch::Internal	signature:( std::nullptr_t, T* rhs )
compare	include/catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, unsigned char rhs )
compare	include/catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, unsigned int rhs )
compare	include/catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( int lhs, unsigned long rhs )
compare	include/catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, unsigned char rhs )
compare	include/catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, unsigned int rhs )
compare	include/catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( long lhs, unsigned long rhs )
compare	include/catch.hpp	/^    template<Operator Op> bool compare( unsigned char lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned char lhs, int rhs )
compare	include/catch.hpp	/^    template<Operator Op> bool compare( unsigned char lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned char lhs, long rhs )
compare	include/catch.hpp	/^    template<Operator Op> bool compare( unsigned int lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned int lhs, int rhs )
compare	include/catch.hpp	/^    template<Operator Op> bool compare( unsigned int lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned int lhs, long rhs )
compare	include/catch.hpp	/^    template<Operator Op> bool compare( unsigned long lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long lhs, int rhs )
compare	include/catch.hpp	/^    template<Operator Op> bool compare( unsigned long lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	signature:( unsigned long lhs, long rhs )
contains	include/catch.hpp	/^    bool contains( std::string const& s, std::string const& infix );$/;"	p	namespace:Catch	signature:( std::string const& s, std::string const& infix )
convert	include/catch.hpp	/^        static std::string convert( T const& ) { return unprintableString; }$/;"	f	struct:Catch::Detail::EnumStringMaker	access:public	signature:( T const& )
convert	include/catch.hpp	/^        static std::string convert( T const& _value ) {$/;"	f	struct:Catch::Detail::StringMakerBase	access:public	signature:( T const& _value )
convert	include/catch.hpp	/^        static std::string convert( T const& v )$/;"	f	struct:Catch::Detail::EnumStringMaker	access:public	signature:( T const& v )
convert	include/catch.hpp	/^        static std::string convert( T const& v )$/;"	f	struct:Catch::Detail::StringMakerBase	access:public	signature:( T const& v )
convert	include/catch.hpp	/^    static std::string convert( R C::* p ) {$/;"	f	struct:Catch::StringMaker	access:public	signature:( R C::* p )
convert	include/catch.hpp	/^    static std::string convert( U* p ) {$/;"	f	struct:Catch::StringMaker	access:public	signature:( U* p )
create	src/headers/window.h	/^	bool create();$/;"	p	class:Window	access:public	signature:()
createGeneratorsForTest	include/catch.hpp	/^    IGeneratorsForTest* createGeneratorsForTest();$/;"	p	namespace:Catch	signature:()
createHeightMap	src/main.cpp	/^static struct heightmap createHeightMap(int width, int height){$/;"	f	file:	signature:(int width, int height)
createLine	src/headers/gamefacade.h	/^		Facade::Line* createLine(Geometry::Line line);$/;"	p	class:GameFacade	access:public	signature:(Geometry::Line line)
createStream	include/catch.hpp	/^    Stream createStream( std::string const& streamName );$/;"	p	namespace:Catch	signature:( std::string const& streamName )
deleteAll	include/catch.hpp	/^    inline void deleteAll( ContainerT& container ) {$/;"	f	namespace:Catch	signature:( ContainerT& container )
deleteAllValues	include/catch.hpp	/^    inline void deleteAllValues( AssociativeContainerT& container ) {$/;"	f	namespace:Catch	signature:( AssociativeContainerT& container )
description	include/catch.hpp	/^    const char* description;$/;"	m	struct:Catch::NameAndDesc	access:public
empty	include/catch.hpp	/^        bool empty() const;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:() const
endExpression	include/catch.hpp	/^        void endExpression();$/;"	p	class:Catch::ResultBuilder	access:public	signature:()
endsWith	include/catch.hpp	/^    bool endsWith( std::string const& s, std::string const& suffix );$/;"	p	namespace:Catch	signature:( std::string const& s, std::string const& suffix )
error_callback	src/main.cpp	/^static void error_callback(int error, const char* description)$/;"	f	file:	signature:(int error, const char* description)
evaluate	include/catch.hpp	/^        static bool evaluate( T1 const& lhs, T2 const& rhs ) {$/;"	f	struct:Catch::Internal::Evaluator	access:public	signature:( T1 const& lhs, T2 const& rhs )
evaluate	include/catch.hpp	/^        static bool evaluate( T1 const& lhs, T2 const& rhs) {$/;"	f	struct:Catch::Internal::Evaluator	access:public	signature:( T1 const& lhs, T2 const& rhs)
file	include/catch.hpp	/^        std::string file;$/;"	m	struct:Catch::SourceLineInfo	access:public
furthest_point	src/main.cpp	/^static glm::vec4 furthest_point;$/;"	v	file:
gamefacade.h	src/headers/gamefacade.h	1;"	F
generate	src/headers/GridGeometry.cpp	/^		int* generate();$/;"	p	class:GridGeomtry	file:	access:public	signature:()
get	include/catch.hpp	/^        T* get() { return m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:()
get	include/catch.hpp	/^        const T* get() const{ return m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
getAllTests	include/catch.hpp	/^        virtual std::vector<TestCase> const& getAllTests() const = 0;$/;"	p	class:Catch::ITestCaseRegistry::std	access:public	signature:() const
getConfig	include/catch.hpp	/^        virtual Ptr<IConfig const> getConfig() const = 0;$/;"	p	struct:Catch::IContext	access:public	signature:() const
getCurrentContext	include/catch.hpp	/^    IContext& getCurrentContext();$/;"	p	namespace:Catch	signature:()
getCurrentIndex	include/catch.hpp	/^        virtual std::size_t getCurrentIndex() const = 0;$/;"	p	struct:Catch::IGeneratorInfo	access:public	signature:() const
getCurrentMutableContext	include/catch.hpp	/^    IMutableContext& getCurrentMutableContext();$/;"	p	namespace:Catch	signature:()
getExpandedExpression	include/catch.hpp	/^        std::string getExpandedExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
getExpression	include/catch.hpp	/^        std::string getExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
getExpressionInMacro	include/catch.hpp	/^        std::string getExpressionInMacro() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
getFilteredTests	include/catch.hpp	/^        virtual void getFilteredTests( TestSpec const& testSpec, IConfig const& config, std::vector<TestCase>& matchingTestCases, bool negated = false ) const = 0;$/;"	p	struct:Catch::ITestCaseRegistry	access:public	signature:( TestSpec const& testSpec, IConfig const& config, std::vector<TestCase>& matchingTestCases, bool negated = false ) const
getGeneratorIndex	include/catch.hpp	/^        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) = 0;$/;"	p	struct:Catch::IContext	access:public	signature:( std::string const& fileInfo, size_t totalSize )
getGeneratorInfo	include/catch.hpp	/^        virtual IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) = 0;$/;"	p	struct:Catch::IGeneratorsForTest	access:public	signature:( std::string const& fileInfo, std::size_t size )
getMessage	include/catch.hpp	/^        std::string getMessage() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
getName	include/catch.hpp	/^    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getName	include/catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getName	include/catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getName	include/catch.hpp	/^    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getName	include/catch.hpp	/^    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getName	include/catch.hpp	/^    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getName	include/catch.hpp	/^    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };$/;"	f	struct:Catch::Internal::OperatorTraits	access:public	signature:()
getResultCapture	include/catch.hpp	/^        virtual IResultCapture* getResultCapture() = 0;$/;"	p	struct:Catch::IContext	access:public	signature:()
getResultType	include/catch.hpp	/^        ResultWas::OfType getResultType() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
getRunner	include/catch.hpp	/^        virtual IRunner* getRunner() = 0;$/;"	p	struct:Catch::IContext	access:public	signature:()
getSourceInfo	include/catch.hpp	/^        SourceLineInfo getSourceInfo() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
getStringForSeverity	src/headers/gldebug.h	/^   static std::string getStringForSeverity(GLenum severity)$/;"	f	class:glDebug	access:private	signature:(GLenum severity)
getStringForSource	src/headers/gldebug.h	/^   static std::string getStringForSource(GLenum source)$/;"	f	class:glDebug	access:private	signature:(GLenum source)
getStringForType	src/headers/gldebug.h	/^   static std::string getStringForType(GLenum type)$/;"	f	class:glDebug	access:private	signature:(GLenum type)
getTestMacroName	include/catch.hpp	/^        std::string getTestMacroName() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
glDebug	src/headers/gldebug.h	/^    glDebug(){};$/;"	f	class:glDebug	access:public	signature:()
glDebug	src/headers/gldebug.h	/^class glDebug{$/;"	c
glDebug::getStringForSeverity	src/headers/gldebug.h	/^   static std::string getStringForSeverity(GLenum severity)$/;"	f	class:glDebug	access:private	signature:(GLenum severity)
glDebug::getStringForSource	src/headers/gldebug.h	/^   static std::string getStringForSource(GLenum source)$/;"	f	class:glDebug	access:private	signature:(GLenum source)
glDebug::getStringForType	src/headers/gldebug.h	/^   static std::string getStringForType(GLenum type)$/;"	f	class:glDebug	access:private	signature:(GLenum type)
glDebug::glDebug	src/headers/gldebug.h	/^    glDebug(){};$/;"	f	class:glDebug	access:public	signature:()
glDebug::myCallback	src/headers/gldebug.h	/^   static void APIENTRY myCallback(GLenum source,$/;"	f	class:glDebug	access:public	signature:(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *msg, GLvoid *data)
glDebug::~glDebug	src/headers/gldebug.h	/^   ~glDebug(){};$/;"	f	class:glDebug	access:public	signature:()
gldebug.h	src/headers/gldebug.h	1;"	F
hasExpandedExpression	include/catch.hpp	/^        bool hasExpandedExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
hasExpression	include/catch.hpp	/^        bool hasExpression() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
hasMessage	include/catch.hpp	/^        bool hasMessage() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
height	src/headers/GridGeometry.cpp	/^		int height;$/;"	m	class:GridGeomtry	file:	access:private
height	src/headers/window.h	/^	int height;$/;"	m	class:Window	access:public
height	src/main.cpp	/^	int height;$/;"	m	struct:heightmap	file:	access:public
height	src/main.cpp	/^static int height = 600;$/;"	v	file:
heightmap	src/main.cpp	/^struct heightmap {$/;"	s	file:
heightmap::height	src/main.cpp	/^	int height;$/;"	m	struct:heightmap	file:	access:public
heightmap::id	src/main.cpp	/^	GLuint id[2];$/;"	m	struct:heightmap	file:	access:public
heightmap::indices	src/main.cpp	/^	int* indices;$/;"	m	struct:heightmap	file:	access:public
heightmap::indicesSize	src/main.cpp	/^	int indicesSize;$/;"	m	struct:heightmap	file:	access:public
heightmap::vertexCount	src/main.cpp	/^	int vertexCount;$/;"	m	struct:heightmap	file:	access:public
heightmap::vertices	src/main.cpp	/^	float* vertices;$/;"	m	struct:heightmap	file:	access:public
heightmap::verticesSize	src/main.cpp	/^	int verticesSize;$/;"	m	struct:heightmap	file:	access:public
heightmap::width	src/main.cpp	/^	int width;$/;"	m	struct:heightmap	file:	access:public
id	src/main.cpp	/^	GLuint id[2];$/;"	m	struct:heightmap	file:	access:public
indexCount	src/headers/GridGeometry.cpp	/^		int indexCount;$/;"	m	class:VisualGrid	file:	access:private
indices	src/headers/GridGeometry.cpp	/^		int* indices;$/;"	m	class:VisualGrid	file:	access:private
indices	src/main.cpp	/^	int* indices;$/;"	m	struct:heightmap	file:	access:public
indicesSize	src/main.cpp	/^	int indicesSize;$/;"	m	struct:heightmap	file:	access:public
instance	src/headers/gamefacade.h	/^		static GameFacade* instance();$/;"	p	class:GameFacade	access:public	signature:()
instance	src/headers/matrixstacksingleton.h	/^		static MatrixStackSingleton* instance();$/;"	p	class:MatrixStackSingleton	access:public	signature:()
instance	src/matrixstacksingleton.cpp	/^MatrixStackSingleton* MatrixStackSingleton::instance(){$/;"	f	class:MatrixStackSingleton	signature:()
invoke	include/catch.hpp	/^        virtual void invoke () const = 0;$/;"	p	struct:Catch::ITestCase	access:public	signature:() const
invoke	include/catch.hpp	/^    virtual void invoke() const {$/;"	f	class:Catch::MethodTestCase	access:public	signature:() const
isFalseTest	include/catch.hpp	/^    inline bool isFalseTest( int flags )                { return ( flags & ResultDisposition::FalseTest ) != 0; }$/;"	f	namespace:Catch	signature:( int flags )
isJustInfo	include/catch.hpp	/^    inline bool isJustInfo( int flags ) {$/;"	f	namespace:Catch	signature:( int flags )
isOk	include/catch.hpp	/^        bool isOk() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
isOk	include/catch.hpp	/^    inline bool isOk( ResultWas::OfType resultType ) {$/;"	f	namespace:Catch	signature:( ResultWas::OfType resultType )
isTrue	include/catch.hpp	/^    inline bool isTrue( bool value ){ return value; }$/;"	f	namespace:Catch	signature:( bool value )
key_callback	src/main.cpp	/^static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)$/;"	f	file:	signature:(GLFWwindow* window, int key, int scancode, int action, int mods)
lhs	include/catch.hpp	/^            std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
line	include/catch.hpp	/^        std::size_t line;$/;"	m	struct:Catch::SourceLineInfo	access:public
line.h	src/headers/facade/line.h	1;"	F
line.h	src/headers/geometry/line.h	1;"	F
line.h	src/headers/visual/line.h	1;"	F
lineInfo	include/catch.hpp	/^        SourceLineInfo lineInfo;$/;"	m	struct:Catch::AssertionInfo	access:public
m_assertionInfo	include/catch.hpp	/^        AssertionInfo m_assertionInfo;$/;"	m	class:Catch::ResultBuilder	access:private
m_count	include/catch.hpp	/^        std::size_t m_count;$/;"	m	struct:Catch::pluralise	access:public
m_data	include/catch.hpp	/^        AssertionResultData m_data;$/;"	m	class:Catch::ResultBuilder	access:private
m_exprComponents	include/catch.hpp	/^        } m_exprComponents;$/;"	m	class:Catch::ResultBuilder	typeref:struct:Catch::ResultBuilder::ExprComponents	access:private
m_info	include/catch.hpp	/^        AssertionInfo m_info;$/;"	m	class:Catch::AssertionResult	access:protected
m_label	include/catch.hpp	/^        std::string m_label;$/;"	m	struct:Catch::pluralise	access:public
m_lineInfo	include/catch.hpp	/^        SourceLineInfo m_lineInfo;$/;"	m	class:Catch::NotImplementedException	access:private
m_method	include/catch.hpp	/^    void (C::*m_method)();$/;"	m	class:Catch::MethodTestCase	access:private
m_p	include/catch.hpp	/^        T* m_p;$/;"	m	class:Catch::Ptr	access:private
m_rc	include/catch.hpp	/^        mutable unsigned int m_rc;$/;"	m	struct:Catch::SharedImpl	access:public
m_resultData	include/catch.hpp	/^        AssertionResultData m_resultData;$/;"	m	class:Catch::AssertionResult	access:protected
m_shouldDebugBreak	include/catch.hpp	/^        bool m_shouldDebugBreak;$/;"	m	class:Catch::ResultBuilder	access:private
m_shouldThrow	include/catch.hpp	/^        bool m_shouldThrow;$/;"	m	class:Catch::ResultBuilder	access:private
m_stream	include/catch.hpp	/^        CopyableStream m_stream;$/;"	m	class:Catch::ResultBuilder	access:private
m_what	include/catch.hpp	/^        std::string m_what;$/;"	m	class:Catch::NotImplementedException	access:private
macroName	include/catch.hpp	/^        std::string macroName;$/;"	m	struct:Catch::AssertionInfo	access:public
main	src/main.cpp	/^int main(void)$/;"	f	signature:(void)
main.cpp	src/main.cpp	1;"	F
main.cpp	tests/main.cpp	1;"	F
makeSafe	include/catch.hpp	/^        static type makeSafe( bool value ) {$/;"	f	class:Catch::SafeBool	access:public	signature:( bool value )
make_shader	src/main.cpp	/^static GLuint make_shader(GLenum type, const char* text)$/;"	f	file:	signature:(GLenum type, const char* text)
make_shader_program	src/main.cpp	/^static GLuint make_shader_program(const char* vs_text, const char* fs_text)$/;"	f	file:	signature:(const char* vs_text, const char* fs_text)
matrixstacksingleton.cpp	src/matrixstacksingleton.cpp	1;"	F
matrixstacksingleton.h	src/headers/matrixstacksingleton.h	1;"	F
matrixstacksingletontests.cpp	tests/matrixstacksingletontests.cpp	1;"	F
me	src/matrixstacksingleton.cpp	/^	glm::mat4 me;$/;"	m	struct:LinkedMatrix	file:	access:public
message	include/catch.hpp	/^        std::string message;$/;"	m	struct:Catch::AssertionResultData	access:public
modelview_matrix	src/main.cpp	/^static glm::mat4 modelview_matrix;$/;"	v	file:
moveNext	include/catch.hpp	/^        virtual bool moveNext() = 0;$/;"	p	struct:Catch::IGeneratorInfo	access:public	signature:()
moveNext	include/catch.hpp	/^        virtual bool moveNext() = 0;$/;"	p	struct:Catch::IGeneratorsForTest	access:public	signature:()
myCallback	src/headers/gldebug.h	/^   static void APIENTRY myCallback(GLenum source,$/;"	f	class:glDebug	access:public	signature:(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *msg, GLvoid *data)
name	include/catch.hpp	/^    const char* name;$/;"	m	struct:Catch::NameAndDesc	access:public
op	include/catch.hpp	/^            std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
opCast	include/catch.hpp	/^    inline T& opCast(T const& t) { return const_cast<T&>(t); }$/;"	f	namespace:Catch::Internal	signature:(T const& t)
opCast	include/catch.hpp	/^    inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }$/;"	f	namespace:Catch::Internal	signature:(std::nullptr_t)
operator !	include/catch.hpp	/^        bool operator !() const { return m_p == NULL; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
operator &&	include/catch.hpp	/^        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && ( RhsT const& );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( RhsT const& )
operator *	include/catch.hpp	/^        T& operator*() const { return *m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
operator +	include/catch.hpp	/^        std::string operator+() {$/;"	f	struct:Catch::StreamEndStop	access:public	signature:()
operator +	include/catch.hpp	/^    T const& operator + ( T const& value, StreamEndStop ) {$/;"	f	namespace:Catch	signature:( T const& value, StreamEndStop )
operator ->	include/catch.hpp	/^        T* operator->() const { return m_p; }$/;"	f	class:Catch::Ptr	access:public	signature:() const
operator <	include/catch.hpp	/^        bool operator < ( SourceLineInfo const& other ) const;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& other ) const
operator <<	include/catch.hpp	/^        ResultBuilder& operator << ( T const& value ) {$/;"	f	class:Catch::ResultBuilder	access:public	signature:( T const& value )
operator <<	include/catch.hpp	/^        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );$/;"	p	struct:Catch::pluralise	access:friend	signature:( std::ostream& os, pluralise const& pluraliser )
operator <<	include/catch.hpp	/^    FalseType operator<<( std::ostream const&, BorgType const& );$/;"	p	namespace:Catch::Detail	signature:( std::ostream const&, BorgType const& )
operator <<	include/catch.hpp	/^    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );$/;"	p	namespace:Catch	signature:( std::ostream& os, SourceLineInfo const& info )
operator <=	include/catch.hpp	/^        ExpressionLhs<T const&> operator <= ( T const& operand );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( T const& operand )
operator <=	include/catch.hpp	/^        ExpressionLhs<bool> operator <= ( bool value );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( bool value )
operator =	include/catch.hpp	/^         AssertionResult& operator = ( AssertionResult && )     = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult && )
operator =	include/catch.hpp	/^         AssertionResult& operator = ( AssertionResult const& ) = default;$/;"	p	class:Catch::AssertionResult	access:public	signature:( AssertionResult const& )
operator =	include/catch.hpp	/^        CopyableStream& operator=( CopyableStream const& other ) {$/;"	f	struct:Catch::CopyableStream	access:public	signature:( CopyableStream const& other )
operator =	include/catch.hpp	/^        NonCopyable& operator = ( NonCopyable && )     = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable && )
operator =	include/catch.hpp	/^        NonCopyable& operator = ( NonCopyable const& ) = delete;$/;"	p	class:Catch::NonCopyable	access:private	signature:( NonCopyable const& )
operator =	include/catch.hpp	/^        Ptr& operator = ( Ptr const& other ){$/;"	f	class:Catch::Ptr	access:public	signature:( Ptr const& other )
operator =	include/catch.hpp	/^        Ptr& operator = ( T* p ){$/;"	f	class:Catch::Ptr	access:public	signature:( T* p )
operator =	include/catch.hpp	/^        SourceLineInfo& operator = ( SourceLineInfo && )     = default;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo && )
operator =	include/catch.hpp	/^        SourceLineInfo& operator = ( SourceLineInfo const& ) = default;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& )
operator =	include/catch.hpp	/^    void operator= ( AutoReg const& );$/;"	p	struct:Catch::AutoReg	access:private	signature:( AutoReg const& )
operator ==	include/catch.hpp	/^        bool operator == ( SourceLineInfo const& other ) const;$/;"	p	struct:Catch::SourceLineInfo	access:public	signature:( SourceLineInfo const& other ) const
operator SafeBool::type	include/catch.hpp	/^        operator SafeBool::type() const { return SafeBool::makeSafe( m_p != NULL ); }$/;"	f	class:Catch::Ptr	access:public	signature:() const
operator |	include/catch.hpp	/^    inline ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {$/;"	f	namespace:Catch	signature:( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs )
operator ||	include/catch.hpp	/^        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || ( RhsT const& );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( RhsT const& )
oss	include/catch.hpp	/^        std::ostringstream oss;$/;"	m	struct:Catch::CopyableStream	access:public
performOptionalSelector	include/catch.hpp	/^id performOptionalSelector( id obj, SEL sel );$/;"	p	signature:( id obj, SEL sel )
performOptionalSelector	include/catch.hpp	/^inline id performOptionalSelector( id obj, SEL sel ) {$/;"	f	signature:( id obj, SEL sel )
pluralise	include/catch.hpp	/^        pluralise( std::size_t count, std::string const& label );$/;"	p	struct:Catch::pluralise	access:public	signature:( std::size_t count, std::string const& label )
pluralise	include/catch.hpp	/^    struct pluralise {$/;"	s	namespace:Catch
point.h	src/headers/geometry/point.h	1;"	F
points	src/headers/GridGeometry.cpp	/^		int* points;$/;"	m	class:GridGeomtry	file:	access:private
pop	src/headers/matrixstacksingleton.h	/^		glm::mat4 pop();$/;"	p	class:MatrixStackSingleton	access:public	signature:()
pop	src/matrixstacksingleton.cpp	/^glm::mat4 MatrixStackSingleton::pop(){$/;"	f	class:MatrixStackSingleton	signature:()
prepRender	src/headers/GridGeometry.cpp	/^		int* prepRender();$/;"	p	class:VisualGrid	file:	access:public	signature:()
prev	src/matrixstacksingleton.cpp	/^	struct LinkedMatrix* prev;$/;"	m	struct:LinkedMatrix	typeref:struct:LinkedMatrix::LinkedMatrix	file:	access:public
projection_matrix	src/main.cpp	/^static glm::mat4 projection_matrix;$/;"	v	file:
push	src/headers/matrixstacksingleton.h	/^		glm::mat4 push(glm::mat4 m);$/;"	p	class:MatrixStackSingleton	access:public	signature:(glm::mat4 m)
push	src/matrixstacksingleton.cpp	/^glm::mat4 MatrixStackSingleton::push(glm::mat4 m){$/;"	f	class:MatrixStackSingleton	signature:(glm::mat4 m)
rangeToString	include/catch.hpp	/^    std::string rangeToString( InputIterator first, InputIterator last );$/;"	p	namespace:Catch::Detail	signature:( InputIterator first, InputIterator last )
rawMemoryToString	include/catch.hpp	/^    inline std::string rawMemoryToString( const T& object ) {$/;"	f	namespace:Catch::Detail	signature:( const T& object )
rawMemoryToString	include/catch.hpp	/^    std::string rawMemoryToString( const void *object, std::size_t size );$/;"	p	namespace:Catch::Detail	signature:( const void *object, std::size_t size )
react	include/catch.hpp	/^        void react();$/;"	p	class:Catch::ResultBuilder	access:public	signature:()
readfile	src/main.cpp	/^static char* readfile(const char* filePath){$/;"	f	file:	signature:(const char* filePath)
reconstructExpression	include/catch.hpp	/^        std::string reconstructExpression() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
reconstructedExpression	include/catch.hpp	/^        std::string reconstructedExpression;$/;"	m	struct:Catch::AssertionResultData	access:public
registerTestCase	include/catch.hpp	/^    void registerTestCase(  ITestCase* testCase,$/;"	p	struct:Catch::AutoReg	access:public	signature:( ITestCase* testCase, char const* className, NameAndDesc const& nameAndDesc, SourceLineInfo const& lineInfo )
release	include/catch.hpp	/^        virtual void release() const = 0;$/;"	p	struct:Catch::IShared	access:public	signature:() const
release	include/catch.hpp	/^        virtual void release() const {$/;"	f	struct:Catch::SharedImpl	access:public	signature:() const
render	src/headers/GridGeometry.cpp	/^		void render(int vertexAttributeIndex);$/;"	p	class:VisualGrid	file:	access:public	signature:(int vertexAttributeIndex)
replaceInPlace	include/catch.hpp	/^    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );$/;"	p	namespace:Catch	signature:( std::string& str, std::string const& replaceThis, std::string const& withThis )
reset	include/catch.hpp	/^        void reset() {$/;"	f	class:Catch::Ptr	access:public	signature:()
resultDisposition	include/catch.hpp	/^        ResultDisposition::Flags resultDisposition;$/;"	m	struct:Catch::AssertionInfo	access:public
resultType	include/catch.hpp	/^        ResultWas::OfType resultType;$/;"	m	struct:Catch::AssertionResultData	access:public
rhs	include/catch.hpp	/^            std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
rows	src/headers/GridGeometry.cpp	/^		int rows;$/;"	m	class:GridGeomtry	file:	access:private
run_from_tmux.sh	run_from_tmux.sh	1;"	F
s	include/catch.hpp	/^        static std::ostream &s;$/;"	m	struct:Catch::Detail::IsStreamInsertable	access:public
setConfig	include/catch.hpp	/^        virtual void setConfig( Ptr<IConfig const> const& config ) = 0;$/;"	p	struct:Catch::IMutableContext	access:public	signature:( Ptr<IConfig const> const& config )
setLhs	include/catch.hpp	/^        ResultBuilder& setLhs( std::string const& lhs );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& lhs )
setOp	include/catch.hpp	/^        ResultBuilder& setOp( std::string const& op );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& op )
setResultCapture	include/catch.hpp	/^        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;$/;"	p	struct:Catch::IMutableContext	access:public	signature:( IResultCapture* resultCapture )
setResultType	include/catch.hpp	/^        ResultBuilder& setResultType( ResultWas::OfType result );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( ResultWas::OfType result )
setResultType	include/catch.hpp	/^        ResultBuilder& setResultType( bool result );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( bool result )
setRhs	include/catch.hpp	/^        ResultBuilder& setRhs( std::string const& rhs );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( std::string const& rhs )
setRunner	include/catch.hpp	/^        virtual void setRunner( IRunner* runner ) = 0;$/;"	p	struct:Catch::IMutableContext	access:public	signature:( IRunner* runner )
shouldClose	src/headers/window.h	/^	bool shouldClose();$/;"	p	class:Window	access:public	signature:()
shouldContinueOnFailure	include/catch.hpp	/^    inline bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }$/;"	f	namespace:Catch	signature:( int flags )
shouldDebugBreak	include/catch.hpp	/^        bool shouldDebugBreak() const;$/;"	p	class:Catch::ResultBuilder	access:public	signature:() const
shouldSuppressFailure	include/catch.hpp	/^    inline bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }$/;"	f	namespace:Catch	signature:( int flags )
sizer	include/catch.hpp	/^    struct FalseType { char sizer[2]; };$/;"	m	struct:Catch::Detail::FalseType	access:public
sizer	include/catch.hpp	/^    struct TrueType { char sizer[1]; };$/;"	m	struct:Catch::Detail::TrueType	access:public
startsWith	include/catch.hpp	/^    bool startsWith( std::string const& s, std::string const& prefix );$/;"	p	namespace:Catch	signature:( std::string const& s, std::string const& prefix )
succeeded	include/catch.hpp	/^        bool succeeded() const;$/;"	p	class:Catch::AssertionResult	access:public	signature:() const
swap	include/catch.hpp	/^        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }$/;"	f	class:Catch::Ptr	access:public	signature:( Ptr& other )
t	include/catch.hpp	/^        static T  const&t;$/;"	m	struct:Catch::Detail::IsStreamInsertable	access:public
testFalse	include/catch.hpp	/^            bool testFalse;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	access:public
testStreamable	include/catch.hpp	/^    FalseType testStreamable( FalseType );$/;"	p	namespace:Catch::Detail	signature:( FalseType )
testStreamable	include/catch.hpp	/^    TrueType& testStreamable( std::ostream& );$/;"	p	namespace:Catch::Detail	signature:( std::ostream& )
tests_from_tmux.sh	tests_from_tmux.sh	1;"	F
throwLogicError	include/catch.hpp	/^    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo );$/;"	p	namespace:Catch	signature:( std::string const& message, SourceLineInfo const& locationInfo )
title	src/headers/window.h	/^	char *title;$/;"	m	class:Window	access:public
toLower	include/catch.hpp	/^    std::string toLower( std::string const& s );$/;"	p	namespace:Catch	signature:( std::string const& s )
toLowerInPlace	include/catch.hpp	/^    void toLowerInPlace( std::string& s );$/;"	p	namespace:Catch	signature:( std::string& s )
toString	include/catch.hpp	/^    std::string toString( NSObject* const& nsObject );$/;"	p	namespace:Catch	signature:( NSObject* const& nsObject )
toString	include/catch.hpp	/^    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring );$/;"	p	namespace:Catch	signature:( NSString * CATCH_ARC_STRONG const& nsstring )
toString	include/catch.hpp	/^    std::string toString( NSString const * const& nsstring );$/;"	p	namespace:Catch	signature:( NSString const * const& nsstring )
toString	include/catch.hpp	/^std::string toString( T const& value );$/;"	p	namespace:Catch	signature:( T const& value )
toString	include/catch.hpp	/^std::string toString( bool value );$/;"	p	namespace:Catch	signature:( bool value )
toString	include/catch.hpp	/^std::string toString( char value );$/;"	p	namespace:Catch	signature:( char value )
toString	include/catch.hpp	/^std::string toString( char* const value );$/;"	p	namespace:Catch	signature:( char* const value )
toString	include/catch.hpp	/^std::string toString( const char* const value );$/;"	p	namespace:Catch	signature:( const char* const value )
toString	include/catch.hpp	/^std::string toString( const double value );$/;"	p	namespace:Catch	signature:( const double value )
toString	include/catch.hpp	/^std::string toString( const float value );$/;"	p	namespace:Catch	signature:( const float value )
toString	include/catch.hpp	/^std::string toString( const wchar_t* const value );$/;"	p	namespace:Catch	signature:( const wchar_t* const value )
toString	include/catch.hpp	/^std::string toString( int value );$/;"	p	namespace:Catch	signature:( int value )
toString	include/catch.hpp	/^std::string toString( signed char value );$/;"	p	namespace:Catch	signature:( signed char value )
toString	include/catch.hpp	/^std::string toString( std::nullptr_t );$/;"	p	namespace:Catch	signature:( std::nullptr_t )
toString	include/catch.hpp	/^std::string toString( std::string const& value );$/;"	p	namespace:Catch	signature:( std::string const& value )
toString	include/catch.hpp	/^std::string toString( std::vector<T,Allocator> const& v ) {$/;"	f	namespace:Catch	signature:( std::vector<T,Allocator> const& v )
toString	include/catch.hpp	/^std::string toString( std::wstring const& value );$/;"	p	namespace:Catch	signature:( std::wstring const& value )
toString	include/catch.hpp	/^std::string toString( unsigned char value );$/;"	p	namespace:Catch	signature:( unsigned char value )
toString	include/catch.hpp	/^std::string toString( unsigned int value );$/;"	p	namespace:Catch	signature:( unsigned int value )
toString	include/catch.hpp	/^std::string toString( unsigned long value );$/;"	p	namespace:Catch	signature:( unsigned long value )
toString	include/catch.hpp	/^std::string toString( wchar_t* const value );$/;"	p	namespace:Catch	signature:( wchar_t* const value )
trim	include/catch.hpp	/^    std::string trim( std::string const& str );$/;"	p	namespace:Catch	signature:( std::string const& str )
trueValue	include/catch.hpp	/^        void trueValue() const {}$/;"	f	class:Catch::SafeBool	access:private	signature:() const
useActiveException	include/catch.hpp	/^        void useActiveException( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal );$/;"	p	class:Catch::ResultBuilder	access:public	signature:( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal )
value	include/catch.hpp	/^        enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };$/;"	e	enum:Catch::Detail::IsStreamInsertable::__anon1
vertexCount	src/main.cpp	/^	int vertexCount;$/;"	m	struct:heightmap	file:	access:public
vertices	src/main.cpp	/^	float* vertices;$/;"	m	struct:heightmap	file:	access:public
verticesSize	src/main.cpp	/^	int verticesSize;$/;"	m	struct:heightmap	file:	access:public
view_angle	src/main.cpp	/^static GLfloat view_angle = 45.0f;$/;"	v	file:
width	src/headers/GridGeometry.cpp	/^		int width;$/;"	m	class:GridGeomtry	file:	access:private
width	src/headers/window.h	/^	int width;$/;"	m	class:Window	access:public
width	src/main.cpp	/^	int width;$/;"	m	struct:heightmap	file:	access:public
width	src/main.cpp	/^static int width = 800;$/;"	v	file:
window	src/headers/window.h	/^		GLFWwindow *window;$/;"	m	class:Window	access:private
window.cpp	src/window.cpp	1;"	F
window.h	src/headers/window.h	1;"	F
z_far	src/main.cpp	/^static GLfloat z_far = 100.f;$/;"	v	file:
z_near	src/main.cpp	/^static GLfloat z_near = 0.1f;$/;"	v	file:
~AssertionResult	include/catch.hpp	/^        ~AssertionResult();$/;"	p	class:Catch::AssertionResult	access:public	signature:()
~AutoReg	include/catch.hpp	/^    ~AutoReg();$/;"	p	struct:Catch::AutoReg	access:public	signature:()
~GameFacade	src/headers/gamefacade.h	/^		~GameFacade();$/;"	p	class:GameFacade	access:protected	signature:()
~GridGeomtry	src/headers/GridGeometry.cpp	/^		~GridGeomtry();$/;"	p	class:GridGeomtry	file:	access:public	signature:()
~IContext	include/catch.hpp	/^        virtual ~IContext();$/;"	p	struct:Catch::IContext	access:public	signature:()
~IGeneratorInfo	include/catch.hpp	/^        virtual ~IGeneratorInfo();$/;"	p	struct:Catch::IGeneratorInfo	access:public	signature:()
~IGeneratorsForTest	include/catch.hpp	/^        virtual ~IGeneratorsForTest();$/;"	p	struct:Catch::IGeneratorsForTest	access:public	signature:()
~IMutableContext	include/catch.hpp	/^        virtual ~IMutableContext();$/;"	p	struct:Catch::IMutableContext	access:public	signature:()
~IShared	include/catch.hpp	/^        virtual ~IShared();$/;"	p	struct:Catch::IShared	access:public	signature:()
~ITestCase	include/catch.hpp	/^        virtual ~ITestCase();$/;"	p	struct:Catch::ITestCase	access:protected	signature:()
~ITestCaseRegistry	include/catch.hpp	/^        virtual ~ITestCaseRegistry();$/;"	p	struct:Catch::ITestCaseRegistry	access:public	signature:()
~Line	src/headers/geometry/line.h	/^			~Line();$/;"	p	class:Geometry::Line	access:public	signature:()
~MatrixStackSingleton	src/headers/matrixstacksingleton.h	/^		~MatrixStackSingleton();$/;"	p	class:MatrixStackSingleton	access:protected	signature:()
~MatrixStackSingleton	src/matrixstacksingleton.cpp	/^MatrixStackSingleton::~MatrixStackSingleton(){$/;"	f	class:MatrixStackSingleton	signature:()
~MethodTestCase	include/catch.hpp	/^    virtual ~MethodTestCase() {}$/;"	f	class:Catch::MethodTestCase	access:private	signature:()
~NonCopyable	include/catch.hpp	/^        virtual ~NonCopyable();$/;"	p	class:Catch::NonCopyable	access:protected	signature:()
~Point	src/headers/geometry/point.h	/^		~Point();$/;"	p	class:Geometry::Point	access:public	signature:()
~Ptr	include/catch.hpp	/^        ~Ptr(){$/;"	f	class:Catch::Ptr	access:public	signature:()
~Window	src/headers/window.h	/^	virtual ~Window();$/;"	p	class:Window	access:public	signature:()
~Window	src/window.cpp	/^Window::~Window(){$/;"	f	class:Window	signature:()
~glDebug	src/headers/gldebug.h	/^   ~glDebug(){};$/;"	f	class:glDebug	access:public	signature:()
